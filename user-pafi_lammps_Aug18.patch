diff -ruN src/atom.cpp clean_src/atom.cpp
--- src/atom.cpp	2018-11-13 15:33:50.822074235 +0100
+++ clean_src/atom.cpp	2018-11-22 17:56:41.530955101 +0100
@@ -99,7 +99,12 @@
   // SPIN package
 
   sp = fm = NULL;
-  
+
+  // USER-PAFI
+
+  pafi_flag = 0;
+  norm = dnorm = path = NULL;
+
   // USER-DPD
 
   uCond = uMech = uChem = uCG = uCGnew = NULL;
@@ -259,6 +264,10 @@
   memory->destroy(v);
   memory->destroy(f);
 
+  memory->destroy(path);
+  memory->destroy(norm);
+  memory->destroy(dnorm);
+  
   memory->destroy(molecule);
   memory->destroy(molindex);
   memory->destroy(molatom);
@@ -429,6 +438,7 @@
   omega_flag = torque_flag = angmom_flag = 0;
   radius_flag = rmass_flag = 0;
   ellipsoid_flag = line_flag = tri_flag = body_flag = 0;
+  pafi_flag = 0;
 
   // magnetic flags
 
@@ -1516,7 +1526,7 @@
    called from reading of input script
 ------------------------------------------------------------------------- */
 
-void Atom::set_mass(const char *file, int line, int narg, char **arg)
+void Atom::set_mass(const char *file, int line, int /*narg*/, char **arg)
 {
   if (mass == NULL) error->all(file,line,"Cannot set mass for this atom style");
 
@@ -2182,6 +2192,11 @@
   if (strcmp(name,"x") == 0) return (void *) x;
   if (strcmp(name,"v") == 0) return (void *) v;
   if (strcmp(name,"f") == 0) return (void *) f;
+
+  if (strcmp(name,"norm") == 0) return (void *) norm;
+  if (strcmp(name,"dnorm") == 0) return (void *) dnorm;
+  if (strcmp(name,"path") == 0) return (void *) path;
+
   if (strcmp(name,"molecule") == 0) return (void *) molecule;
   if (strcmp(name,"q") == 0) return (void *) q;
   if (strcmp(name,"mu") == 0) return (void *) mu;
diff -ruN src/atom.h clean_src/atom.h
--- src/atom.h	2018-11-13 15:33:50.822074235 +0100
+++ clean_src/atom.h	2018-11-22 17:56:41.530955101 +0100
@@ -71,6 +71,11 @@
   double *vfrac,*s0;
   double **x0;
 
+  // USER-PAFI package
+
+  int pafi_flag;
+  double **path, **norm, **dnorm;
+
   // USER-EFF and USER-AWPMD packages
 
   int *spin;
diff -ruN src/library.cpp clean_src/library.cpp
--- src/library.cpp	2018-11-13 15:33:50.870074937 +0100
+++ clean_src/library.cpp	2018-11-22 17:56:23.334728635 +0100
@@ -906,6 +906,83 @@
   END_CAPTURE
 }
 
+
+/* ----------------------------------------------------------------------
+  Contributing author: Thomas Swinburne (CNRS & CINaM, Marseille, France)
+   gather the named per atom fix and return it in user-allocated data
+   extract_fix does not work when running lammps in parallel
+   data will be ordered by atom ID
+     requirement for consecutive atom IDs (1 to N)
+   gather_fix_concat() gather_fix_subset() not implemented yet....
+   id = fix ID
+   count: number of entries per atom
+   Fills 1d data, which must be pre-allocated to length of count * Natoms, where Natoms is as queried by get_natoms()
+   method:
+     alloc and zero count*Natom length vector
+     loop over Nlocal to fill vector with my values
+     Allreduce to sum vector into data across all procs
+------------------------------------------------------------------------- */
+
+void lammps_gather_peratom_fix(void *ptr, char *id, int count, void *data)
+{
+  LAMMPS *lmp = (LAMMPS *) ptr;
+
+  BEGIN_CAPTURE
+  {
+    int i,j,offset;
+
+    int ifix = lmp->modify->find_fix(id);
+    if (ifix < 0) {
+      lmp->error->warning(FLERR,"lammps_gather_fix: unknown fix id");
+      return;
+    }
+
+    Fix *fix = lmp->modify->fix[ifix];
+    int natoms = static_cast<int> (lmp->atom->natoms);
+
+    // error if tags are not defined or not consecutive
+    int flag = 0;
+    if (lmp->atom->tag_enable == 0 || lmp->atom->tag_consecutive() == 0)
+      flag = 1;
+    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
+    if (flag) {
+      if (lmp->comm->me == 0)
+        lmp->error->warning(FLERR,"Library error in lammps_gather_peratom_fix");
+      return;
+    }
+
+    // copy = Natom length vector of per-atom values
+    // use atom ID to insert each atom's values into copy
+    // MPI_Allreduce with MPI_SUM to merge into data, ordered by atom ID
+
+    double *vector = NULL;
+    double **array = NULL;
+    if (count == 1) vector = (double *) fix->vector_atom; //vptr;
+    else array = (double **) fix->array_atom; //vptr;
+
+    double *copy;
+    lmp->memory->create(copy,count*natoms,"lib/gather:copy");
+    for (i = 0; i < count*natoms; i++) copy[i] = 0.0;
+
+    tagint *tag = lmp->atom->tag;
+    int nlocal = lmp->atom->nlocal;
+
+    if (count == 1) {
+      for (i = 0; i < nlocal; i++)
+        copy[tag[i]-1] = vector[i];
+    } else {
+      for (i = 0; i < nlocal; i++) {
+        offset = count*(tag[i]-1);
+        for (j = 0; j < count; j++)
+          copy[offset++] = array[i][j];
+      }
+    }
+    MPI_Allreduce(copy,data,count*natoms,MPI_DOUBLE,MPI_SUM,lmp->world);
+    lmp->memory->destroy(copy);
+  }
+  END_CAPTURE
+}
+
 /* ----------------------------------------------------------------------
    gather the named atom-based entity for all atoms
      return it in user-allocated data
@@ -957,7 +1034,7 @@
     }
 
     // perform MPI_Allgatherv on each proc's chunk of Nlocal atoms
-    
+
     int nprocs = lmp->comm->nprocs;
 
     int *recvcounts,*displs;
@@ -1078,7 +1155,7 @@
   LAMMPS *lmp = (LAMMPS *) ptr;
 
   BEGIN_CAPTURE
-  { 
+  {
     int i,j,m,offset;
     tagint id;
 
@@ -1319,9 +1396,9 @@
 ------------------------------------------------------------------------- */
 
 void lammps_scatter_atoms_subset(void *ptr, char *name,
-                                 int type, int count, 
+                                 int type, int count,
                                  int ndata, int *ids, void *data)
-{ 
+{
   LAMMPS *lmp = (LAMMPS *) ptr;
 
   BEGIN_CAPTURE
diff -ruN src/library.h clean_src/library.h
--- src/library.h	2018-11-13 15:33:50.870074937 +0100
+++ clean_src/library.h	2018-11-22 17:56:23.334728635 +0100
@@ -52,6 +52,8 @@
 void lammps_gather_atoms(void *, char *, int, int, void *);
 void lammps_gather_atoms_concat(void *, char *, int, int, void *);
 void lammps_gather_atoms_subset(void *, char *, int, int, int, int *, void *);
+void lammps_gather_peratom_fix(void *, char *, int, void *);
+
 void lammps_scatter_atoms(void *, char *, int, int, void *);
 void lammps_scatter_atoms_subset(void *, char *, int, int, int, int *, void *);
 
diff -ruN src/USER-PAFI/atom_vec_pafi.cpp clean_src/USER-PAFI/atom_vec_pafi.cpp
--- src/USER-PAFI/atom_vec_pafi.cpp	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/atom_vec_pafi.cpp	2018-11-22 17:56:09.902560588 +0100
@@ -0,0 +1,951 @@
+/* ----------------------------------------------------------------------
+
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+
+------------------------------------------------------------------------- */
+
+/* ------------------------------------------------------------------------
+   Contributing authors: Thomas Swinburne (CNRS & CINaM, Marseille, France)
+
+   Please cite the related publication:
+   T.D. Swinburne and M.-C. Marinica, Unsupervised calculation of free energy barriers in large crystalline systems, Physical Review Letters 2018
+------------------------------------------------------------------------- */
+#include <cmath>
+#include <cstdlib>
+#include <cstring>
+#include "atom.h"
+#include "atom_vec_pafi.h"
+#include "comm.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "memory.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+AtomVecPAFI::AtomVecPAFI(LAMMPS *lmp) : AtomVec(lmp)
+{
+  molecular = 0;
+  mass_type = 1;
+  comm_x_only = 1;
+  comm_f_only = 1;
+  size_forward = 3;
+  size_reverse = 3;
+  size_border = 15;
+  size_velocity = 3;
+  size_data_atom = 5;//14;
+  size_data_vel = 4;
+  xcol_data = 3;
+  atom->pafi_flag = 1;
+}
+
+
+/* ----------------------------------------------------------------------
+   grow atom arrays
+   n = 0 grows arrays by a chunk
+   n > 0 allocates arrays to size n
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::grow(int n)
+{
+  if (n == 0) grow_nmax();
+  else nmax = n;
+  atom->nmax = nmax;
+  if (nmax < 0 || nmax > MAXSMALLINT)
+    error->one(FLERR,"Per-processor system is too big");
+
+  tag = memory->grow(atom->tag,nmax,"atom:tag");
+  type = memory->grow(atom->type,nmax,"atom:type");
+  mask = memory->grow(atom->mask,nmax,"atom:mask");
+  image = memory->grow(atom->image,nmax,"atom:image");
+
+  // allocating mech. quantities
+
+  x = memory->grow(atom->x,nmax,3,"atom:x");
+  v = memory->grow(atom->v,nmax,3,"atom:v");
+  f = memory->grow(atom->f,nmax*comm->nthreads,3,"atom:f");
+
+  // allocating path quantities
+  path = memory->grow(atom->path,nmax,3,"atom:path");
+  norm = memory->grow(atom->norm,nmax,3,"atom:norm");
+  dnorm = memory->grow(atom->dnorm,nmax,3,"atom:dnorm");
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      modify->fix[atom->extra_grow[iextra]]->grow_arrays(nmax);
+}
+
+/* ----------------------------------------------------------------------
+   reset local array ptrs
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::grow_reset()
+{
+  tag = atom->tag; type = atom->type;
+  mask = atom->mask; image = atom->image;
+  x = atom->x; v = atom->v; f = atom->f;
+  path = atom->path; norm = atom->norm; dnorm = atom->dnorm;
+}
+
+
+/* ----------------------------------------------------------------------
+   copy atom I info to atom J
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::copy(int i, int j, int delflag)
+{
+  tag[j] = tag[i];
+  type[j] = type[i];
+  mask[j] = mask[i];
+  image[j] = image[i];
+  x[j][0] = x[i][0];
+  x[j][1] = x[i][1];
+  x[j][2] = x[i][2];
+
+  v[j][0] = v[i][0];
+  v[j][1] = v[i][1];
+  v[j][2] = v[i][2];
+
+  path[j][0] = path[i][0];
+  path[j][1] = path[i][1];
+  path[j][2] = path[i][2];
+
+  norm[j][0] = norm[i][0];
+  norm[j][1] = norm[i][1];
+  norm[j][2] = norm[i][2];
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      modify->fix[atom->extra_grow[iextra]]->copy_arrays(i,j,delflag);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_comm(int n, int *list, double *buf,
+                             int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0]*domain->xprd + pbc[5]*domain->xy + pbc[4]*domain->xz;
+      dy = pbc[1]*domain->yprd + pbc[3]*domain->yz;
+      dz = pbc[2]*domain->zprd;
+    }
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0] + dx;
+      buf[m++] = x[j][1] + dy;
+      buf[m++] = x[j][2] + dz;
+    }
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_comm_vel(int n, int *list, double *buf,
+                                 int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz,dvx,dvy,dvz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+      buf[m++] = v[j][0];
+      buf[m++] = v[j][1];
+      buf[m++] = v[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0]*domain->xprd + pbc[5]*domain->xy + pbc[4]*domain->xz;
+      dy = pbc[1]*domain->yprd + pbc[3]*domain->yz;
+      dz = pbc[2]*domain->zprd;
+    }
+    if (!deform_vremap) {
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        buf[m++] = v[j][0];
+        buf[m++] = v[j][1];
+        buf[m++] = v[j][2];
+      }
+    } else {
+      dvx = pbc[0]*h_rate[0] + pbc[5]*h_rate[5] + pbc[4]*h_rate[4];
+      dvy = pbc[1]*h_rate[1] + pbc[3]*h_rate[3];
+      dvz = pbc[2]*h_rate[2];
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        if (mask[i] & deform_groupbit) {
+          buf[m++] = v[j][0] + dvx;
+          buf[m++] = v[j][1] + dvy;
+          buf[m++] = v[j][2] + dvz;
+        } else {
+          buf[m++] = v[j][0];
+          buf[m++] = v[j][1];
+          buf[m++] = v[j][2];
+        }
+      }
+    }
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFI::unpack_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFI::unpack_comm_vel(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+    v[i][0] = buf[m++];
+    v[i][1] = buf[m++];
+    v[i][2] = buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_reverse(int n, int first, double *buf)
+{
+  int i,m,last;
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    buf[m++] = f[i][0];
+    buf[m++] = f[i][1];
+    buf[m++] = f[i][2];
+  }
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFI::unpack_reverse(int n, int *list, double *buf)
+{
+  int i,j,m;
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    f[j][0] += buf[m++];
+    f[j][1] += buf[m++];
+    f[j][2] += buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_border(int n, int *list, double *buf,
+                               int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+      buf[m++] = ubuf(tag[j]).d;
+      buf[m++] = ubuf(type[j]).d;
+      buf[m++] = ubuf(mask[j]).d;
+      buf[m++] = path[j][0];
+      buf[m++] = path[j][1];
+      buf[m++] = path[j][2];
+      buf[m++] = norm[j][0];
+      buf[m++] = norm[j][1];
+      buf[m++] = norm[j][2];
+      buf[m++] = dnorm[j][0];
+      buf[m++] = dnorm[j][1];
+      buf[m++] = dnorm[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0];
+      dy = pbc[1];
+      dz = pbc[2];
+    }
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0] + dx;
+      buf[m++] = x[j][1] + dy;
+      buf[m++] = x[j][2] + dz;
+      buf[m++] = ubuf(tag[j]).d;
+      buf[m++] = ubuf(type[j]).d;
+      buf[m++] = ubuf(mask[j]).d;
+      buf[m++] = path[j][0];
+      buf[m++] = path[j][1];
+      buf[m++] = path[j][2];
+      buf[m++] = norm[j][0];
+      buf[m++] = norm[j][1];
+      buf[m++] = norm[j][2];
+      buf[m++] = dnorm[j][0];
+      buf[m++] = dnorm[j][1];
+      buf[m++] = dnorm[j][2];
+    }
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->pack_border(n,list,&buf[m]);
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_border_vel(int n, int *list, double *buf,
+                                   int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz,dvx,dvy,dvz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+      buf[m++] = ubuf(tag[j]).d;
+      buf[m++] = ubuf(type[j]).d;
+      buf[m++] = ubuf(mask[j]).d;
+      buf[m++] = path[j][0];
+      buf[m++] = path[j][1];
+      buf[m++] = path[j][2];
+      buf[m++] = norm[j][0];
+      buf[m++] = norm[j][1];
+      buf[m++] = norm[j][2];
+      buf[m++] = dnorm[j][0];
+      buf[m++] = dnorm[j][1];
+      buf[m++] = dnorm[j][2];
+      buf[m++] = v[j][0];
+      buf[m++] = v[j][1];
+      buf[m++] = v[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0];
+      dy = pbc[1];
+      dz = pbc[2];
+    }
+    if (!deform_vremap) {
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        buf[m++] = ubuf(tag[j]).d;
+        buf[m++] = ubuf(type[j]).d;
+        buf[m++] = ubuf(mask[j]).d;
+        buf[m++] = path[j][0];
+        buf[m++] = path[j][1];
+        buf[m++] = path[j][2];
+        buf[m++] = norm[j][0];
+        buf[m++] = norm[j][1];
+        buf[m++] = norm[j][2];
+        buf[m++] = dnorm[j][0];
+        buf[m++] = dnorm[j][1];
+        buf[m++] = dnorm[j][2];
+        buf[m++] = v[j][0];
+        buf[m++] = v[j][1];
+        buf[m++] = v[j][2];
+      }
+    } else {
+      dvx = pbc[0]*h_rate[0] + pbc[5]*h_rate[5] + pbc[4]*h_rate[4];
+      dvy = pbc[1]*h_rate[1] + pbc[3]*h_rate[3];
+      dvz = pbc[2]*h_rate[2];
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        buf[m++] = ubuf(tag[j]).d;
+        buf[m++] = ubuf(type[j]).d;
+        buf[m++] = ubuf(mask[j]).d;
+        buf[m++] = path[j][0];
+        buf[m++] = path[j][1];
+        buf[m++] = path[j][2];
+        buf[m++] = norm[j][0];
+        buf[m++] = norm[j][1];
+        buf[m++] = norm[j][2];
+        buf[m++] = dnorm[j][0];
+        buf[m++] = dnorm[j][1];
+        buf[m++] = dnorm[j][2];
+        if (mask[i] & deform_groupbit) {
+          buf[m++] = v[j][0] + dvx;
+          buf[m++] = v[j][1] + dvy;
+          buf[m++] = v[j][2] + dvz;
+        } else {
+          buf[m++] = v[j][0];
+          buf[m++] = v[j][1];
+          buf[m++] = v[j][2];
+        }
+      }
+    }
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->pack_border(n,list,&buf[m]);
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_border_hybrid(int n, int *list, double *buf)
+{
+  int i,j,m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    buf[m++] = path[j][0];
+    buf[m++] = path[j][1];
+    buf[m++] = path[j][2];
+    buf[m++] = norm[j][0];
+    buf[m++] = norm[j][1];
+    buf[m++] = norm[j][2];
+    buf[m++] = dnorm[j][0];
+    buf[m++] = dnorm[j][1];
+    buf[m++] = dnorm[j][2];
+  }
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFI::unpack_border(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    if (i == nmax) grow(0);
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+    tag[i] = (tagint) ubuf(buf[m++]).i;
+    type[i] = (int) ubuf(buf[m++]).i;
+    mask[i] = (int) ubuf(buf[m++]).i;
+    path[i][0] = buf[m++];
+    path[i][1] = buf[m++];
+    path[i][2] = buf[m++];
+    norm[i][0] = buf[m++];
+    norm[i][1] = buf[m++];
+    norm[i][2] = buf[m++];
+    dnorm[i][0] = buf[m++];
+    dnorm[i][1] = buf[m++];
+    dnorm[i][2] = buf[m++];
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->
+        unpack_border(n,first,&buf[m]);
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFI::unpack_border_vel(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    if (i == nmax) grow(0);
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+    tag[i] = (tagint) ubuf(buf[m++]).i;
+    type[i] = (int) ubuf(buf[m++]).i;
+    mask[i] = (int) ubuf(buf[m++]).i;
+    path[i][0] = buf[m++];
+    path[i][1] = buf[m++];
+    path[i][2] = buf[m++];
+    norm[i][0] = buf[m++];
+    norm[i][1] = buf[m++];
+    norm[i][2] = buf[m++];
+    dnorm[i][0] = buf[m++];
+    dnorm[i][1] = buf[m++];
+    dnorm[i][2] = buf[m++];
+    v[i][0] = buf[m++];
+    v[i][1] = buf[m++];
+    v[i][2] = buf[m++];
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->
+        unpack_border(n,first,&buf[m]);
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::unpack_border_hybrid(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    path[i][0] = buf[m++];
+    path[i][1] = buf[m++];
+    path[i][2] = buf[m++];
+    norm[i][0] = buf[m++];
+    norm[i][1] = buf[m++];
+    norm[i][2] = buf[m++];
+    dnorm[i][0] = buf[m++];
+    dnorm[i][1] = buf[m++];
+    dnorm[i][2] = buf[m++];
+  }
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   pack all atom quantities for shipping to another proc
+   xyz must be 1st 3 values, so that comm::exchange can test on them
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_exchange(int i, double *buf)
+{
+  int m = 1;
+  buf[m++] = x[i][0];
+  buf[m++] = x[i][1];
+  buf[m++] = x[i][2];
+  buf[m++] = v[i][0];
+  buf[m++] = v[i][1];
+  buf[m++] = v[i][2];
+  buf[m++] = ubuf(tag[i]).d;
+  buf[m++] = ubuf(type[i]).d;
+  buf[m++] = ubuf(mask[i]).d;
+  buf[m++] = ubuf(image[i]).d;
+
+  buf[m++] = path[i][0];
+  buf[m++] = path[i][1];
+  buf[m++] = path[i][2];
+  buf[m++] = norm[i][0];
+  buf[m++] = norm[i][1];
+  buf[m++] = norm[i][2];
+  buf[m++] = dnorm[i][0];
+  buf[m++] = dnorm[i][1];
+  buf[m++] = dnorm[i][2];
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      m += modify->fix[atom->extra_grow[iextra]]->pack_exchange(i,&buf[m]);
+
+  buf[0] = m;
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFI::unpack_exchange(double *buf)
+{
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) grow(0);
+
+  int m = 1;
+  x[nlocal][0] = buf[m++];
+  x[nlocal][1] = buf[m++];
+  x[nlocal][2] = buf[m++];
+  v[nlocal][0] = buf[m++];
+  v[nlocal][1] = buf[m++];
+  v[nlocal][2] = buf[m++];
+  tag[nlocal] = (tagint) ubuf(buf[m++]).i;
+  type[nlocal] = (int) ubuf(buf[m++]).i;
+  mask[nlocal] = (int) ubuf(buf[m++]).i;
+  image[nlocal] = (imageint) ubuf(buf[m++]).i;
+
+  path[nlocal][0] = buf[m++];
+  path[nlocal][1] = buf[m++];
+  path[nlocal][2] = buf[m++];
+  norm[nlocal][0] = buf[m++];
+  norm[nlocal][1] = buf[m++];
+  norm[nlocal][2] = buf[m++];
+  dnorm[nlocal][0] = buf[m++];
+  dnorm[nlocal][1] = buf[m++];
+  dnorm[nlocal][2] = buf[m++];
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      m += modify->fix[atom->extra_grow[iextra]]->
+        unpack_exchange(nlocal,&buf[m]);
+
+  atom->nlocal++;
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   size of restart data for all atoms owned by this proc
+   include extra data stored by fixes
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::size_restart()
+{
+  int i;
+
+  int nlocal = atom->nlocal;
+  int n = 20 * nlocal;
+
+  if (atom->nextra_restart)
+    for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
+      for (i = 0; i < nlocal; i++)
+        n += modify->fix[atom->extra_restart[iextra]]->size_restart(i);
+
+  return n;
+}
+
+/* ----------------------------------------------------------------------
+   pack atom I's data for restart file including extra quantities
+   xyz must be 1st 3 values, so that read_restart can test on them
+   molecular types may be negative, but write as positive
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_restart(int i, double *buf)
+{
+  int m = 1;
+
+  buf[m++] = x[i][0];
+  buf[m++] = x[i][1];
+  buf[m++] = x[i][2];
+  buf[m++] = ubuf(tag[i]).d;
+  buf[m++] = ubuf(type[i]).d;
+  buf[m++] = ubuf(mask[i]).d;
+  buf[m++] = ubuf(image[i]).d;
+  buf[m++] = v[i][0];
+  buf[m++] = v[i][1];
+  buf[m++] = v[i][2];
+
+  buf[m++] = path[i][0];
+  buf[m++] = path[i][1];
+  buf[m++] = path[i][2];
+  buf[m++] = norm[i][0];
+  buf[m++] = norm[i][1];
+  buf[m++] = norm[i][2];
+  buf[m++] = dnorm[i][0];
+  buf[m++] = dnorm[i][1];
+  buf[m++] = dnorm[i][2];
+
+  if (atom->nextra_restart)
+    for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
+      m += modify->fix[atom->extra_restart[iextra]]->pack_restart(i,&buf[m]);
+
+  buf[0] = m;
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   unpack data for one atom from restart file including extra quantities
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::unpack_restart(double *buf)
+{
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) {
+    grow(0);
+    if (atom->nextra_store)
+      memory->grow(atom->extra,nmax,atom->nextra_store,"atom:extra");
+  }
+
+  int m = 1;
+  x[nlocal][0] = buf[m++];
+  x[nlocal][1] = buf[m++];
+  x[nlocal][2] = buf[m++];
+  tag[nlocal] = (tagint) ubuf(buf[m++]).i;
+  type[nlocal] = (int) ubuf(buf[m++]).i;
+  mask[nlocal] = (int) ubuf(buf[m++]).i;
+  image[nlocal] = (imageint) ubuf(buf[m++]).i;
+  v[nlocal][0] = buf[m++];
+  v[nlocal][1] = buf[m++];
+  v[nlocal][2] = buf[m++];
+
+  path[nlocal][0] = buf[m++];
+  path[nlocal][1] = buf[m++];
+  path[nlocal][2] = buf[m++];
+  norm[nlocal][0] = buf[m++];
+  norm[nlocal][1] = buf[m++];
+  norm[nlocal][2] = buf[m++];
+  dnorm[nlocal][0] = buf[m++];
+  dnorm[nlocal][1] = buf[m++];
+  dnorm[nlocal][2] = buf[m++];
+
+  double **extra = atom->extra;
+  if (atom->nextra_store) {
+    int size = static_cast<int> (buf[0]) - m;
+    for (int i = 0; i < size; i++) extra[nlocal][i] = buf[m++];
+  }
+
+  atom->nlocal++;
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   create one atom of itype at coord
+   set other values to defaults
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::create_atom(int itype, double *coord)
+{
+
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) grow(0);
+
+  tag[nlocal] = 0;
+  type[nlocal] = itype;
+  x[nlocal][0] = coord[0];
+  x[nlocal][1] = coord[1];
+  x[nlocal][2] = coord[2];
+  mask[nlocal] = 1;
+  image[nlocal] = ((imageint) IMGMAX << IMG2BITS) |
+    ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+  v[nlocal][0] = 0.0;
+  v[nlocal][1] = 0.0;
+  v[nlocal][2] = 0.0;
+
+  path[nlocal][0] = 0.0;
+  path[nlocal][1] = 0.0;
+  path[nlocal][2] = 0.0;
+  norm[nlocal][0] = 0.0;
+  norm[nlocal][1] = 0.0;
+  norm[nlocal][2] = 0.0;
+  dnorm[nlocal][0] = 0.0;
+  dnorm[nlocal][1] = 0.0;
+  dnorm[nlocal][2] = 0.0;
+
+  atom->nlocal++;
+}
+
+/* ----------------------------------------------------------------------
+   unpack one line from Atoms section of data file
+   initialize other atom quantities
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::data_atom(double *coord, imageint imagetmp, char **values)
+{
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) grow(0);
+
+  tag[nlocal] = ATOTAGINT(values[0]);
+  type[nlocal] = atoi(values[1]);
+  if (type[nlocal] <= 0 || type[nlocal] > atom->ntypes)
+    error->one(FLERR,"Invalid atom type in Atoms section of data file");
+
+  x[nlocal][0] = coord[0];
+  x[nlocal][1] = coord[1];
+  x[nlocal][2] = coord[2];
+
+  path[nlocal][0] = 0.;
+  path[nlocal][1] = 0.;
+  path[nlocal][2] = 0.;
+
+  norm[nlocal][0] = 0.;
+  norm[nlocal][1] = 0.;
+  norm[nlocal][2] = 0.;
+
+  dnorm[nlocal][0] = 0.;
+  dnorm[nlocal][1] = 0.;
+  dnorm[nlocal][2] = 0.;
+
+  image[nlocal] = imagetmp;
+
+  mask[nlocal] = 1;
+  v[nlocal][0] = 0.0;
+  v[nlocal][1] = 0.0;
+  v[nlocal][2] = 0.0;
+
+  atom->nlocal++;
+}
+
+/* ----------------------------------------------------------------------
+   unpack hybrid quantities from one line in Atoms section of data file
+   initialize other atom quantities for this sub-style
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::data_atom_hybrid(int nlocal, char **values)
+{
+
+  path[nlocal][0] = atof(values[0]);
+  path[nlocal][1] = atof(values[1]);
+  path[nlocal][2] = atof(values[2]);
+
+  norm[nlocal][0] = atof(values[3]);
+  norm[nlocal][1] = atof(values[4]);
+  norm[nlocal][2] = atof(values[5]);
+
+  dnorm[nlocal][0] = atof(values[6]);
+  dnorm[nlocal][1] = atof(values[7]);
+  dnorm[nlocal][2] = atof(values[8]);
+
+  return 9;
+}
+
+/* ----------------------------------------------------------------------
+   pack atom info for data file including 3 image flags
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::pack_data(double **buf)
+{
+  int nlocal = atom->nlocal;
+  for (int i = 0; i < nlocal; i++) {
+    buf[i][0] = ubuf(tag[i]).d;
+    buf[i][1] = ubuf(type[i]).d;
+    buf[i][2] = x[i][0];
+    buf[i][3] = x[i][1];
+    buf[i][4] = x[i][2];
+
+    buf[i][5] = ubuf((image[i] & IMGMASK) - IMGMAX).d;
+    buf[i][6] = ubuf((image[i] >> IMGBITS & IMGMASK) - IMGMAX).d;
+    buf[i][7] = ubuf((image[i] >> IMG2BITS) - IMGMAX).d;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   pack hybrid atom info for data file
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::pack_data_hybrid(int i, double *buf)
+{
+  buf[0] = path[i][0];
+  buf[1] = path[i][1];
+  buf[2] = path[i][2];
+
+  buf[3] = norm[i][0];
+  buf[4] = norm[i][1];
+  buf[5] = norm[i][2];
+
+  buf[6] = dnorm[i][0];
+  buf[7] = dnorm[i][1];
+  buf[8] = dnorm[i][2];
+  return 9;
+}
+
+/* ----------------------------------------------------------------------
+   write atom info to data file including 3 image flags
+------------------------------------------------------------------------- */
+
+void AtomVecPAFI::write_data(FILE *fp, int n, double **buf)
+{
+  for (int i = 0; i < n; i++)
+    fprintf(fp,TAGINT_FORMAT \
+            " %d %-1.16e %-1.16e %-1.16e %d %d %d\n",
+            (tagint) ubuf(buf[i][0]).i,(int) ubuf(buf[i][1]).i,
+            buf[i][2],buf[i][3],buf[i][4],
+            (int) ubuf(buf[i][5]).i,(int) ubuf(buf[i][6]).i,
+            (int) ubuf(buf[i][7]).i);
+}
+
+/* ----------------------------------------------------------------------
+   write hybrid atom info to data file
+------------------------------------------------------------------------- */
+
+int AtomVecPAFI::write_data_hybrid(FILE *fp, double *buf)
+{
+  fprintf(fp,"%-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e",
+  buf[0],buf[1],buf[2],
+  buf[3],buf[4],buf[5],
+  buf[6],buf[7],buf[8]);
+  return 9;
+}
+
+/* ----------------------------------------------------------------------
+   return # of bytes of allocated memory
+------------------------------------------------------------------------- */
+
+bigint AtomVecPAFI::memory_usage()
+{
+  bigint bytes = 0;
+
+  if (atom->memcheck("tag")) bytes += memory->usage(tag,nmax);
+  if (atom->memcheck("type")) bytes += memory->usage(type,nmax);
+  if (atom->memcheck("mask")) bytes += memory->usage(mask,nmax);
+  if (atom->memcheck("image")) bytes += memory->usage(image,nmax);
+  if (atom->memcheck("x")) bytes += memory->usage(x,nmax,3);
+  if (atom->memcheck("v")) bytes += memory->usage(v,nmax,3);
+  if (atom->memcheck("f")) bytes += memory->usage(f,nmax*comm->nthreads,3);
+
+  if (atom->memcheck("path")) bytes += memory->usage(path,nmax,3);
+  if (atom->memcheck("norm")) bytes += memory->usage(norm,nmax,3);
+  if (atom->memcheck("dnorm")) bytes += memory->usage(dnorm,nmax,3);
+
+  return bytes;
+}
diff -ruN src/USER-PAFI/atom_vec_pafi.h clean_src/USER-PAFI/atom_vec_pafi.h
--- src/USER-PAFI/atom_vec_pafi.h	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/atom_vec_pafi.h	2018-11-22 17:56:09.902560588 +0100
@@ -0,0 +1,91 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+/* ------------------------------------------------------------------------
+   Contributing authors: Thomas Swinburne (CNRS & CINaM, Marseille, France)
+
+   Please cite the related publication:
+   T.D. Swinburne and M.-C. Marinica, Unsupervised calculation of free energy barriers in large crystalline systems, Physical Review Letters 2018
+------------------------------------------------------------------------- */
+
+
+#ifdef ATOM_CLASS
+
+AtomStyle(pafi,AtomVecPAFI)
+
+#else
+
+#ifndef LMP_ATOM_VEC_PAFI_H
+#define LMP_ATOM_VEC_PAFI_H
+
+#include "atom_vec.h"
+
+namespace LAMMPS_NS {
+
+class AtomVecPAFI : public AtomVec {
+ public:
+  AtomVecPAFI(class LAMMPS *);
+  void grow(int);
+  void grow_reset();
+  void copy(int, int, int);
+  int pack_comm(int, int *, double *, int, int *);
+  int pack_comm_vel(int, int *, double *, int, int *);
+  void unpack_comm(int, int, double *);
+  void unpack_comm_vel(int, int, double *);
+  int pack_reverse(int, int, double *);
+  void unpack_reverse(int, int *, double *);
+  int pack_border(int, int *, double *, int, int *);
+  int pack_border_vel(int, int *, double *, int, int *);
+  int pack_border_hybrid(int, int *, double *);
+  void unpack_border(int, int, double *);
+  void unpack_border_vel(int, int, double *);
+  int unpack_border_hybrid(int, int, double *);
+  int pack_exchange(int, double *);
+  int unpack_exchange(double *);
+  int size_restart();
+  int pack_restart(int, double *);
+  int unpack_restart(double *);
+  void create_atom(int, double *);
+  virtual void data_atom(double *, imageint, char **);
+  virtual int data_atom_hybrid(int, char **);
+  virtual void pack_data(double **);
+  virtual int pack_data_hybrid(int, double *);
+  virtual void write_data(FILE *, int, double **);
+  virtual int write_data_hybrid(FILE *, double *);
+  bigint memory_usage();
+
+ private:
+  tagint *tag;
+  int *type,*mask;
+  imageint *image;
+  double **x,**v,**f;		// lattice quantities
+  // 0th, 1st and 2nd derivative of reference path w.r.t. to path coordinate r
+  double **path,**norm,**dnorm;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Per-processor system is too big
+
+The number of owned atoms plus ghost atoms on a single
+processor must fit in 32-bit integer.
+
+E: Invalid atom type in Atoms section of data file
+
+Atom types must range from 1 to specified # of types.
+
+*/
diff -ruN src/USER-PAFI/atom_vec_pafipath.cpp clean_src/USER-PAFI/atom_vec_pafipath.cpp
--- src/USER-PAFI/atom_vec_pafipath.cpp	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/atom_vec_pafipath.cpp	2018-11-22 17:56:09.906560638 +0100
@@ -0,0 +1,967 @@
+/* ----------------------------------------------------------------------
+
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+
+------------------------------------------------------------------------- */
+
+/* ------------------------------------------------------------------------
+   Contributing authors: Thomas Swinburne (CNRS & CINaM, Marseille, France)
+
+   Please cite the related publication:
+   T.D. Swinburne and M.-C. Marinica, Unsupervised calculation of free energy barriers in large crystalline systems, Physical Review Letters 2018
+------------------------------------------------------------------------- */
+#include <cmath>
+#include <cstdlib>
+#include <cstring>
+#include "atom.h"
+#include "atom_vec_pafipath.h"
+#include "comm.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "memory.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+AtomVecPAFIPATH::AtomVecPAFIPATH(LAMMPS *lmp) : AtomVec(lmp)
+{
+  molecular = 0;
+  mass_type = 1;
+  comm_x_only = 1;
+  comm_f_only = 1;
+  size_forward = 3;
+  size_reverse = 3;
+  size_border = 15;
+  size_velocity = 3;
+  size_data_atom = 14;
+  size_data_vel = 4;
+  xcol_data = 3;
+  atom->pafi_flag = 1;
+}
+
+
+/* ----------------------------------------------------------------------
+   grow atom arrays
+   n = 0 grows arrays by a chunk
+   n > 0 allocates arrays to size n
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::grow(int n)
+{
+  if (n == 0) grow_nmax();
+  else nmax = n;
+  atom->nmax = nmax;
+  if (nmax < 0 || nmax > MAXSMALLINT)
+    error->one(FLERR,"Per-processor system is too big");
+
+  tag = memory->grow(atom->tag,nmax,"atom:tag");
+  type = memory->grow(atom->type,nmax,"atom:type");
+  mask = memory->grow(atom->mask,nmax,"atom:mask");
+  image = memory->grow(atom->image,nmax,"atom:image");
+
+  // allocating mech. quantities
+
+  x = memory->grow(atom->x,nmax,3,"atom:x");
+  v = memory->grow(atom->v,nmax,3,"atom:v");
+  f = memory->grow(atom->f,nmax*comm->nthreads,3,"atom:f");
+
+  // allocating path quantities
+  path = memory->grow(atom->path,nmax,3,"atom:path");
+  norm = memory->grow(atom->norm,nmax,3,"atom:norm");
+  dnorm = memory->grow(atom->dnorm,nmax,3,"atom:dnorm");
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      modify->fix[atom->extra_grow[iextra]]->grow_arrays(nmax);
+}
+
+/* ----------------------------------------------------------------------
+   reset local array ptrs
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::grow_reset()
+{
+  tag = atom->tag; type = atom->type;
+  mask = atom->mask; image = atom->image;
+  x = atom->x; v = atom->v; f = atom->f;
+  path = atom->path; norm = atom->norm; dnorm = atom->dnorm;
+}
+
+
+/* ----------------------------------------------------------------------
+   copy atom I info to atom J
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::copy(int i, int j, int delflag)
+{
+  tag[j] = tag[i];
+  type[j] = type[i];
+  mask[j] = mask[i];
+  image[j] = image[i];
+  x[j][0] = x[i][0];
+  x[j][1] = x[i][1];
+  x[j][2] = x[i][2];
+
+  v[j][0] = v[i][0];
+  v[j][1] = v[i][1];
+  v[j][2] = v[i][2];
+
+  path[j][0] = path[i][0];
+  path[j][1] = path[i][1];
+  path[j][2] = path[i][2];
+
+  norm[j][0] = norm[i][0];
+  norm[j][1] = norm[i][1];
+  norm[j][2] = norm[i][2];
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      modify->fix[atom->extra_grow[iextra]]->copy_arrays(i,j,delflag);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_comm(int n, int *list, double *buf,
+                             int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0]*domain->xprd + pbc[5]*domain->xy + pbc[4]*domain->xz;
+      dy = pbc[1]*domain->yprd + pbc[3]*domain->yz;
+      dz = pbc[2]*domain->zprd;
+    }
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0] + dx;
+      buf[m++] = x[j][1] + dy;
+      buf[m++] = x[j][2] + dz;
+    }
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_comm_vel(int n, int *list, double *buf,
+                                 int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz,dvx,dvy,dvz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+      buf[m++] = v[j][0];
+      buf[m++] = v[j][1];
+      buf[m++] = v[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0]*domain->xprd + pbc[5]*domain->xy + pbc[4]*domain->xz;
+      dy = pbc[1]*domain->yprd + pbc[3]*domain->yz;
+      dz = pbc[2]*domain->zprd;
+    }
+    if (!deform_vremap) {
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        buf[m++] = v[j][0];
+        buf[m++] = v[j][1];
+        buf[m++] = v[j][2];
+      }
+    } else {
+      dvx = pbc[0]*h_rate[0] + pbc[5]*h_rate[5] + pbc[4]*h_rate[4];
+      dvy = pbc[1]*h_rate[1] + pbc[3]*h_rate[3];
+      dvz = pbc[2]*h_rate[2];
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        if (mask[i] & deform_groupbit) {
+          buf[m++] = v[j][0] + dvx;
+          buf[m++] = v[j][1] + dvy;
+          buf[m++] = v[j][2] + dvz;
+        } else {
+          buf[m++] = v[j][0];
+          buf[m++] = v[j][1];
+          buf[m++] = v[j][2];
+        }
+      }
+    }
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::unpack_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::unpack_comm_vel(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+    v[i][0] = buf[m++];
+    v[i][1] = buf[m++];
+    v[i][2] = buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_reverse(int n, int first, double *buf)
+{
+  int i,m,last;
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    buf[m++] = f[i][0];
+    buf[m++] = f[i][1];
+    buf[m++] = f[i][2];
+  }
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::unpack_reverse(int n, int *list, double *buf)
+{
+  int i,j,m;
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    f[j][0] += buf[m++];
+    f[j][1] += buf[m++];
+    f[j][2] += buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_border(int n, int *list, double *buf,
+                               int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+      buf[m++] = ubuf(tag[j]).d;
+      buf[m++] = ubuf(type[j]).d;
+      buf[m++] = ubuf(mask[j]).d;
+      buf[m++] = path[j][0];
+      buf[m++] = path[j][1];
+      buf[m++] = path[j][2];
+      buf[m++] = norm[j][0];
+      buf[m++] = norm[j][1];
+      buf[m++] = norm[j][2];
+      buf[m++] = dnorm[j][0];
+      buf[m++] = dnorm[j][1];
+      buf[m++] = dnorm[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0];
+      dy = pbc[1];
+      dz = pbc[2];
+    }
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0] + dx;
+      buf[m++] = x[j][1] + dy;
+      buf[m++] = x[j][2] + dz;
+      buf[m++] = ubuf(tag[j]).d;
+      buf[m++] = ubuf(type[j]).d;
+      buf[m++] = ubuf(mask[j]).d;
+      buf[m++] = path[j][0];
+      buf[m++] = path[j][1];
+      buf[m++] = path[j][2];
+      buf[m++] = norm[j][0];
+      buf[m++] = norm[j][1];
+      buf[m++] = norm[j][2];
+      buf[m++] = dnorm[j][0];
+      buf[m++] = dnorm[j][1];
+      buf[m++] = dnorm[j][2];
+    }
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->pack_border(n,list,&buf[m]);
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_border_vel(int n, int *list, double *buf,
+                                   int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz,dvx,dvy,dvz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = x[j][0];
+      buf[m++] = x[j][1];
+      buf[m++] = x[j][2];
+      buf[m++] = ubuf(tag[j]).d;
+      buf[m++] = ubuf(type[j]).d;
+      buf[m++] = ubuf(mask[j]).d;
+      buf[m++] = path[j][0];
+      buf[m++] = path[j][1];
+      buf[m++] = path[j][2];
+      buf[m++] = norm[j][0];
+      buf[m++] = norm[j][1];
+      buf[m++] = norm[j][2];
+      buf[m++] = dnorm[j][0];
+      buf[m++] = dnorm[j][1];
+      buf[m++] = dnorm[j][2];
+      buf[m++] = v[j][0];
+      buf[m++] = v[j][1];
+      buf[m++] = v[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0];
+      dy = pbc[1];
+      dz = pbc[2];
+    }
+    if (!deform_vremap) {
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        buf[m++] = ubuf(tag[j]).d;
+        buf[m++] = ubuf(type[j]).d;
+        buf[m++] = ubuf(mask[j]).d;
+        buf[m++] = path[j][0];
+        buf[m++] = path[j][1];
+        buf[m++] = path[j][2];
+        buf[m++] = norm[j][0];
+        buf[m++] = norm[j][1];
+        buf[m++] = norm[j][2];
+        buf[m++] = dnorm[j][0];
+        buf[m++] = dnorm[j][1];
+        buf[m++] = dnorm[j][2];
+        buf[m++] = v[j][0];
+        buf[m++] = v[j][1];
+        buf[m++] = v[j][2];
+      }
+    } else {
+      dvx = pbc[0]*h_rate[0] + pbc[5]*h_rate[5] + pbc[4]*h_rate[4];
+      dvy = pbc[1]*h_rate[1] + pbc[3]*h_rate[3];
+      dvz = pbc[2]*h_rate[2];
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = x[j][0] + dx;
+        buf[m++] = x[j][1] + dy;
+        buf[m++] = x[j][2] + dz;
+        buf[m++] = ubuf(tag[j]).d;
+        buf[m++] = ubuf(type[j]).d;
+        buf[m++] = ubuf(mask[j]).d;
+        buf[m++] = path[j][0];
+        buf[m++] = path[j][1];
+        buf[m++] = path[j][2];
+        buf[m++] = norm[j][0];
+        buf[m++] = norm[j][1];
+        buf[m++] = norm[j][2];
+        buf[m++] = dnorm[j][0];
+        buf[m++] = dnorm[j][1];
+        buf[m++] = dnorm[j][2];
+        if (mask[i] & deform_groupbit) {
+          buf[m++] = v[j][0] + dvx;
+          buf[m++] = v[j][1] + dvy;
+          buf[m++] = v[j][2] + dvz;
+        } else {
+          buf[m++] = v[j][0];
+          buf[m++] = v[j][1];
+          buf[m++] = v[j][2];
+        }
+      }
+    }
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->pack_border(n,list,&buf[m]);
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_border_hybrid(int n, int *list, double *buf)
+{
+  int i,j,m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    buf[m++] = path[j][0];
+    buf[m++] = path[j][1];
+    buf[m++] = path[j][2];
+    buf[m++] = norm[j][0];
+    buf[m++] = norm[j][1];
+    buf[m++] = norm[j][2];
+    buf[m++] = dnorm[j][0];
+    buf[m++] = dnorm[j][1];
+    buf[m++] = dnorm[j][2];
+  }
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::unpack_border(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    if (i == nmax) grow(0);
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+    tag[i] = (tagint) ubuf(buf[m++]).i;
+    type[i] = (int) ubuf(buf[m++]).i;
+    mask[i] = (int) ubuf(buf[m++]).i;
+    path[i][0] = buf[m++];
+    path[i][1] = buf[m++];
+    path[i][2] = buf[m++];
+    norm[i][0] = buf[m++];
+    norm[i][1] = buf[m++];
+    norm[i][2] = buf[m++];
+    dnorm[i][0] = buf[m++];
+    dnorm[i][1] = buf[m++];
+    dnorm[i][2] = buf[m++];
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->
+        unpack_border(n,first,&buf[m]);
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::unpack_border_vel(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    if (i == nmax) grow(0);
+    x[i][0] = buf[m++];
+    x[i][1] = buf[m++];
+    x[i][2] = buf[m++];
+    tag[i] = (tagint) ubuf(buf[m++]).i;
+    type[i] = (int) ubuf(buf[m++]).i;
+    mask[i] = (int) ubuf(buf[m++]).i;
+    path[i][0] = buf[m++];
+    path[i][1] = buf[m++];
+    path[i][2] = buf[m++];
+    norm[i][0] = buf[m++];
+    norm[i][1] = buf[m++];
+    norm[i][2] = buf[m++];
+    dnorm[i][0] = buf[m++];
+    dnorm[i][1] = buf[m++];
+    dnorm[i][2] = buf[m++];
+    v[i][0] = buf[m++];
+    v[i][1] = buf[m++];
+    v[i][2] = buf[m++];
+  }
+
+  if (atom->nextra_border)
+    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
+      m += modify->fix[atom->extra_border[iextra]]->
+        unpack_border(n,first,&buf[m]);
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::unpack_border_hybrid(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    path[i][0] = buf[m++];
+    path[i][1] = buf[m++];
+    path[i][2] = buf[m++];
+    norm[i][0] = buf[m++];
+    norm[i][1] = buf[m++];
+    norm[i][2] = buf[m++];
+    dnorm[i][0] = buf[m++];
+    dnorm[i][1] = buf[m++];
+    dnorm[i][2] = buf[m++];
+  }
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   pack all atom quantities for shipping to another proc
+   xyz must be 1st 3 values, so that comm::exchange can test on them
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_exchange(int i, double *buf)
+{
+  int m = 1;
+  buf[m++] = x[i][0];
+  buf[m++] = x[i][1];
+  buf[m++] = x[i][2];
+  buf[m++] = v[i][0];
+  buf[m++] = v[i][1];
+  buf[m++] = v[i][2];
+  buf[m++] = ubuf(tag[i]).d;
+  buf[m++] = ubuf(type[i]).d;
+  buf[m++] = ubuf(mask[i]).d;
+  buf[m++] = ubuf(image[i]).d;
+
+  buf[m++] = path[i][0];
+  buf[m++] = path[i][1];
+  buf[m++] = path[i][2];
+  buf[m++] = norm[i][0];
+  buf[m++] = norm[i][1];
+  buf[m++] = norm[i][2];
+  buf[m++] = dnorm[i][0];
+  buf[m++] = dnorm[i][1];
+  buf[m++] = dnorm[i][2];
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      m += modify->fix[atom->extra_grow[iextra]]->pack_exchange(i,&buf[m]);
+
+  buf[0] = m;
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::unpack_exchange(double *buf)
+{
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) grow(0);
+
+  int m = 1;
+  x[nlocal][0] = buf[m++];
+  x[nlocal][1] = buf[m++];
+  x[nlocal][2] = buf[m++];
+  v[nlocal][0] = buf[m++];
+  v[nlocal][1] = buf[m++];
+  v[nlocal][2] = buf[m++];
+  tag[nlocal] = (tagint) ubuf(buf[m++]).i;
+  type[nlocal] = (int) ubuf(buf[m++]).i;
+  mask[nlocal] = (int) ubuf(buf[m++]).i;
+  image[nlocal] = (imageint) ubuf(buf[m++]).i;
+
+  path[nlocal][0] = buf[m++];
+  path[nlocal][1] = buf[m++];
+  path[nlocal][2] = buf[m++];
+  norm[nlocal][0] = buf[m++];
+  norm[nlocal][1] = buf[m++];
+  norm[nlocal][2] = buf[m++];
+  dnorm[nlocal][0] = buf[m++];
+  dnorm[nlocal][1] = buf[m++];
+  dnorm[nlocal][2] = buf[m++];
+
+  if (atom->nextra_grow)
+    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
+      m += modify->fix[atom->extra_grow[iextra]]->
+        unpack_exchange(nlocal,&buf[m]);
+
+  atom->nlocal++;
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   size of restart data for all atoms owned by this proc
+   include extra data stored by fixes
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::size_restart()
+{
+  int i;
+
+  int nlocal = atom->nlocal;
+  int n = 20 * nlocal;
+
+  if (atom->nextra_restart)
+    for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
+      for (i = 0; i < nlocal; i++)
+        n += modify->fix[atom->extra_restart[iextra]]->size_restart(i);
+
+  return n;
+}
+
+/* ----------------------------------------------------------------------
+   pack atom I's data for restart file including extra quantities
+   xyz must be 1st 3 values, so that read_restart can test on them
+   molecular types may be negative, but write as positive
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_restart(int i, double *buf)
+{
+  int m = 1;
+
+  buf[m++] = x[i][0];
+  buf[m++] = x[i][1];
+  buf[m++] = x[i][2];
+  buf[m++] = ubuf(tag[i]).d;
+  buf[m++] = ubuf(type[i]).d;
+  buf[m++] = ubuf(mask[i]).d;
+  buf[m++] = ubuf(image[i]).d;
+  buf[m++] = v[i][0];
+  buf[m++] = v[i][1];
+  buf[m++] = v[i][2];
+
+  buf[m++] = path[i][0];
+  buf[m++] = path[i][1];
+  buf[m++] = path[i][2];
+  buf[m++] = norm[i][0];
+  buf[m++] = norm[i][1];
+  buf[m++] = norm[i][2];
+  buf[m++] = dnorm[i][0];
+  buf[m++] = dnorm[i][1];
+  buf[m++] = dnorm[i][2];
+
+  if (atom->nextra_restart)
+    for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
+      m += modify->fix[atom->extra_restart[iextra]]->pack_restart(i,&buf[m]);
+
+  buf[0] = m;
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   unpack data for one atom from restart file including extra quantities
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::unpack_restart(double *buf)
+{
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) {
+    grow(0);
+    if (atom->nextra_store)
+      memory->grow(atom->extra,nmax,atom->nextra_store,"atom:extra");
+  }
+
+  int m = 1;
+  x[nlocal][0] = buf[m++];
+  x[nlocal][1] = buf[m++];
+  x[nlocal][2] = buf[m++];
+  tag[nlocal] = (tagint) ubuf(buf[m++]).i;
+  type[nlocal] = (int) ubuf(buf[m++]).i;
+  mask[nlocal] = (int) ubuf(buf[m++]).i;
+  image[nlocal] = (imageint) ubuf(buf[m++]).i;
+  v[nlocal][0] = buf[m++];
+  v[nlocal][1] = buf[m++];
+  v[nlocal][2] = buf[m++];
+
+  path[nlocal][0] = buf[m++];
+  path[nlocal][1] = buf[m++];
+  path[nlocal][2] = buf[m++];
+  norm[nlocal][0] = buf[m++];
+  norm[nlocal][1] = buf[m++];
+  norm[nlocal][2] = buf[m++];
+  dnorm[nlocal][0] = buf[m++];
+  dnorm[nlocal][1] = buf[m++];
+  dnorm[nlocal][2] = buf[m++];
+
+  double **extra = atom->extra;
+  if (atom->nextra_store) {
+    int size = static_cast<int> (buf[0]) - m;
+    for (int i = 0; i < size; i++) extra[nlocal][i] = buf[m++];
+  }
+
+  atom->nlocal++;
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   create one atom of itype at coord
+   set other values to defaults
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::create_atom(int itype, double *coord)
+{
+
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) grow(0);
+
+  tag[nlocal] = 0;
+  type[nlocal] = itype;
+  x[nlocal][0] = coord[0];
+  x[nlocal][1] = coord[1];
+  x[nlocal][2] = coord[2];
+  mask[nlocal] = 1;
+  image[nlocal] = ((imageint) IMGMAX << IMG2BITS) |
+    ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+  v[nlocal][0] = 0.0;
+  v[nlocal][1] = 0.0;
+  v[nlocal][2] = 0.0;
+
+  path[nlocal][0] = 0.0;
+  path[nlocal][1] = 0.0;
+  path[nlocal][2] = 0.0;
+  norm[nlocal][0] = 0.0;
+  norm[nlocal][1] = 0.0;
+  norm[nlocal][2] = 0.0;
+  dnorm[nlocal][0] = 0.0;
+  dnorm[nlocal][1] = 0.0;
+  dnorm[nlocal][2] = 0.0;
+
+  atom->nlocal++;
+}
+
+/* ----------------------------------------------------------------------
+   unpack one line from Atoms section of data file
+   initialize other atom quantities
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::data_atom(double *coord, imageint imagetmp, char **values)
+{
+  int nlocal = atom->nlocal;
+  if (nlocal == nmax) grow(0);
+
+  tag[nlocal] = ATOTAGINT(values[0]);
+  type[nlocal] = atoi(values[1]);
+  if (type[nlocal] <= 0 || type[nlocal] > atom->ntypes)
+    error->one(FLERR,"Invalid atom type in Atoms section of data file");
+
+  x[nlocal][0] = coord[0];
+  x[nlocal][1] = coord[1];
+  x[nlocal][2] = coord[2];
+
+  path[nlocal][0] = atof(values[5]);
+  path[nlocal][1] = atof(values[6]);
+  path[nlocal][2] = atof(values[7]);
+
+  norm[nlocal][0] = atof(values[8]);
+  norm[nlocal][1] = atof(values[9]);
+  norm[nlocal][2] = atof(values[10]);
+
+  dnorm[nlocal][0] = atof(values[11]);
+  dnorm[nlocal][1] = atof(values[12]);
+  dnorm[nlocal][2] = atof(values[13]);
+
+  image[nlocal] = imagetmp;
+
+  mask[nlocal] = 1;
+  v[nlocal][0] = 0.0;
+  v[nlocal][1] = 0.0;
+  v[nlocal][2] = 0.0;
+
+  atom->nlocal++;
+}
+
+/* ----------------------------------------------------------------------
+   unpack hybrid quantities from one line in Atoms section of data file
+   initialize other atom quantities for this sub-style
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::data_atom_hybrid(int nlocal, char **values)
+{
+
+  path[nlocal][0] = atof(values[0]);
+  path[nlocal][1] = atof(values[1]);
+  path[nlocal][2] = atof(values[2]);
+
+  norm[nlocal][0] = atof(values[3]);
+  norm[nlocal][1] = atof(values[4]);
+  norm[nlocal][2] = atof(values[5]);
+
+  dnorm[nlocal][0] = atof(values[6]);
+  dnorm[nlocal][1] = atof(values[7]);
+  dnorm[nlocal][2] = atof(values[8]);
+
+  return 9;
+}
+
+/* ----------------------------------------------------------------------
+   pack atom info for data file including 3 image flags
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::pack_data(double **buf)
+{
+  int nlocal = atom->nlocal;
+  for (int i = 0; i < nlocal; i++) {
+    buf[i][0] = ubuf(tag[i]).d;
+    buf[i][1] = ubuf(type[i]).d;
+    buf[i][2] = x[i][0];
+    buf[i][3] = x[i][1];
+    buf[i][4] = x[i][2];
+
+    buf[i][5] = path[i][0];
+    buf[i][6] = path[i][1];
+    buf[i][7] = path[i][2];
+
+    buf[i][8] = norm[i][0];
+    buf[i][9] = norm[i][1];
+    buf[i][10] = norm[i][2];
+
+    buf[i][11] = dnorm[i][0];
+    buf[i][12] = dnorm[i][1];
+    buf[i][13] = dnorm[i][2];
+
+    buf[i][14] = ubuf((image[i] & IMGMASK) - IMGMAX).d;
+    buf[i][15] = ubuf((image[i] >> IMGBITS & IMGMASK) - IMGMAX).d;
+    buf[i][16] = ubuf((image[i] >> IMG2BITS) - IMGMAX).d;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   pack hybrid atom info for data file
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::pack_data_hybrid(int i, double *buf)
+{
+  buf[0] = path[i][0];
+  buf[1] = path[i][1];
+  buf[2] = path[i][2];
+
+  buf[3] = norm[i][0];
+  buf[4] = norm[i][1];
+  buf[5] = norm[i][2];
+
+  buf[6] = dnorm[i][0];
+  buf[7] = dnorm[i][1];
+  buf[8] = dnorm[i][2];
+  return 9;
+}
+
+/* ----------------------------------------------------------------------
+   write atom info to data file including 3 image flags
+------------------------------------------------------------------------- */
+
+void AtomVecPAFIPATH::write_data(FILE *fp, int n, double **buf)
+{
+  for (int i = 0; i < n; i++)
+    fprintf(fp,TAGINT_FORMAT \
+            " %d %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e"
+            " %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %d %d %d\n",
+            (tagint) ubuf(buf[i][0]).i,(int) ubuf(buf[i][1]).i,
+            buf[i][2],buf[i][3],buf[i][4],
+            buf[i][5],buf[i][6],buf[i][7],
+            buf[i][8],buf[i][9],buf[i][10],
+            buf[i][11],buf[i][12],buf[i][13],
+            (int) ubuf(buf[i][14]).i,(int) ubuf(buf[i][15]).i,
+            (int) ubuf(buf[i][16]).i);
+}
+
+/* ----------------------------------------------------------------------
+   write hybrid atom info to data file
+------------------------------------------------------------------------- */
+
+int AtomVecPAFIPATH::write_data_hybrid(FILE *fp, double *buf)
+{
+  fprintf(fp,"%-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e",
+  buf[0],buf[1],buf[2],
+  buf[3],buf[4],buf[5],
+  buf[6],buf[7],buf[8]);
+  return 9;
+}
+
+/* ----------------------------------------------------------------------
+   return # of bytes of allocated memory
+------------------------------------------------------------------------- */
+
+bigint AtomVecPAFIPATH::memory_usage()
+{
+  bigint bytes = 0;
+
+  if (atom->memcheck("tag")) bytes += memory->usage(tag,nmax);
+  if (atom->memcheck("type")) bytes += memory->usage(type,nmax);
+  if (atom->memcheck("mask")) bytes += memory->usage(mask,nmax);
+  if (atom->memcheck("image")) bytes += memory->usage(image,nmax);
+  if (atom->memcheck("x")) bytes += memory->usage(x,nmax,3);
+  if (atom->memcheck("v")) bytes += memory->usage(v,nmax,3);
+  if (atom->memcheck("f")) bytes += memory->usage(f,nmax*comm->nthreads,3);
+
+  if (atom->memcheck("path")) bytes += memory->usage(path,nmax,3);
+  if (atom->memcheck("norm")) bytes += memory->usage(norm,nmax,3);
+  if (atom->memcheck("dnorm")) bytes += memory->usage(dnorm,nmax,3);
+
+  return bytes;
+}
diff -ruN src/USER-PAFI/atom_vec_pafipath.h clean_src/USER-PAFI/atom_vec_pafipath.h
--- src/USER-PAFI/atom_vec_pafipath.h	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/atom_vec_pafipath.h	2018-11-22 17:56:09.906560638 +0100
@@ -0,0 +1,91 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+/* ------------------------------------------------------------------------
+   Contributing authors: Thomas Swinburne (CNRS & CINaM, Marseille, France)
+
+   Please cite the related publication:
+   T.D. Swinburne and M.-C. Marinica, Unsupervised calculation of free energy barriers in large crystalline systems, Physical Review Letters 2018
+------------------------------------------------------------------------- */
+
+
+#ifdef ATOM_CLASS
+
+AtomStyle(pafipath,AtomVecPAFIPATH)
+
+#else
+
+#ifndef LMP_ATOM_VEC_PAFIPATH_H
+#define LMP_ATOM_VEC_PAFIPATH_H
+
+#include "atom_vec.h"
+
+namespace LAMMPS_NS {
+
+class AtomVecPAFIPATH : public AtomVec {
+ public:
+  AtomVecPAFIPATH(class LAMMPS *);
+  void grow(int);
+  void grow_reset();
+  void copy(int, int, int);
+  int pack_comm(int, int *, double *, int, int *);
+  int pack_comm_vel(int, int *, double *, int, int *);
+  void unpack_comm(int, int, double *);
+  void unpack_comm_vel(int, int, double *);
+  int pack_reverse(int, int, double *);
+  void unpack_reverse(int, int *, double *);
+  int pack_border(int, int *, double *, int, int *);
+  int pack_border_vel(int, int *, double *, int, int *);
+  int pack_border_hybrid(int, int *, double *);
+  void unpack_border(int, int, double *);
+  void unpack_border_vel(int, int, double *);
+  int unpack_border_hybrid(int, int, double *);
+  int pack_exchange(int, double *);
+  int unpack_exchange(double *);
+  int size_restart();
+  int pack_restart(int, double *);
+  int unpack_restart(double *);
+  void create_atom(int, double *);
+  virtual void data_atom(double *, imageint, char **);
+  virtual int data_atom_hybrid(int, char **);
+  virtual void pack_data(double **);
+  virtual int pack_data_hybrid(int, double *);
+  virtual void write_data(FILE *, int, double **);
+  virtual int write_data_hybrid(FILE *, double *);
+  bigint memory_usage();
+
+ private:
+  tagint *tag;
+  int *type,*mask;
+  imageint *image;
+  double **x,**v,**f;		// lattice quantities
+  // 0th, 1st and 2nd derivative of reference path w.r.t. to path coordinate r
+  double **path,**norm,**dnorm;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Per-processor system is too big
+
+The number of owned atoms plus ghost atoms on a single
+processor must fit in 32-bit integer.
+
+E: Invalid atom type in Atoms section of data file
+
+Atom types must range from 1 to specified # of types.
+
+*/
diff -ruN src/USER-PAFI/fix_ave_deviation.cpp clean_src/USER-PAFI/fix_ave_deviation.cpp
--- src/USER-PAFI/fix_ave_deviation.cpp	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/fix_ave_deviation.cpp	2018-11-22 17:56:09.906560638 +0100
@@ -0,0 +1,259 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+#include <cstdlib>
+#include <cstring>
+#include "fix_ave_deviation.h"
+#include "atom.h"
+#include "domain.h"
+#include "update.h"
+#include "modify.h"
+#include "compute.h"
+#include "input.h"
+#include "variable.h"
+#include "memory.h"
+#include "error.h"
+#include "force.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+#define INVOKED_PERATOM 8
+
+/* ---------------------------------------------------------------------- */
+
+FixAveDeviation::FixAveDeviation(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), nvalues(3), array(NULL)
+{
+  if (narg < 6) error->all(FLERR,"Illegal fix ave/deviation command");
+
+  if (!atom->pafi_flag) error->all(FLERR,"Fix ave/deviation requires atom_style pafi or pafipath");
+
+  nevery = force->inumeric(FLERR,arg[3]);
+  nrepeat = force->inumeric(FLERR,arg[4]);
+  peratom_freq = force->inumeric(FLERR,arg[5]);
+
+  // this fix produces a per-atom array
+  nvalues = 3;
+  peratom_flag = 1;
+  array_flag = 1;
+  size_peratom_cols = 3;
+
+  // perform initial allocation of atom-based array
+  // register with Atom class
+  grow_arrays(atom->nmax);
+  atom->add_callback(0);
+
+  // set to initial deviation
+
+  int nlocal = atom->nlocal;
+  int *mask = atom->mask;
+  double **x = atom->x;
+  double **path = atom->path;
+  double deviation[3] = {0.,0.,0.};
+  for (int i = 0; i < nlocal; i++) if (mask[i] & groupbit) {
+    for(int j=0;j<3;j++) deviation[j] = x[i][j]-path[i][j]; // x-path
+    domain->minimum_image(deviation);
+    for(int j=0;j<3;j++) array[i][j] = deviation[j];
+  }
+
+  // nvalid = next step on which end_of_step does something
+  // add nvalid to all computes that store invocation times
+  // since don't know a priori which are invoked by this fix
+  // once in end_of_step() can set timestep for ones actually invoked
+
+  irepeat = 0;
+  nvalid_last = -1;
+  nvalid = nextvalid();
+  modify->addstep_compute_all(nvalid);
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixAveDeviation::~FixAveDeviation()
+{
+  // unregister callback to this fix from Atom class
+
+  atom->delete_callback(id,0);
+  memory->destroy(array);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixAveDeviation::setmask()
+{
+  int mask = 0;
+  mask |= END_OF_STEP;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixAveDeviation::init()
+{
+  // need to reset nvalid if nvalid < ntimestep b/c minimize was performed
+  if (nvalid < update->ntimestep) {
+    irepeat = 0;
+    nvalid = nextvalid();
+    modify->addstep_compute_all(nvalid);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   only does something if nvalid = current timestep
+------------------------------------------------------------------------- */
+
+void FixAveDeviation::setup(int vflag)
+{
+  end_of_step();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixAveDeviation::end_of_step()
+{
+  int i,j,m,n;
+
+  // skip if not step which requires doing something
+  // error check if timestep was reset in an invalid manner
+
+  bigint ntimestep = update->ntimestep;
+  if (ntimestep < nvalid_last || ntimestep > nvalid)
+    error->all(FLERR,"Invalid timestep reset for fix ave/deviation");
+  if (ntimestep != nvalid) return;
+  nvalid_last = nvalid;
+
+  // zero if first step
+
+  int nlocal = atom->nlocal;
+
+  if (irepeat == 0)
+    for (i = 0; i < nlocal; i++)
+      for (m = 0; m < nvalues; m++)
+        array[i][m] = 0.0;
+
+  // accumulate results of attributes,computes,fixes,variables to local copy
+  // compute/fix/variable may invoke computes so wrap with clear/add
+
+  //modify->clearstep_compute();
+
+  int *mask = atom->mask;
+  double **x = atom->x;
+  double **path = atom->path;
+  double deviation[3] = {0.,0.,0.};
+  for (i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit) {
+      for(int j=0;j<3;j++) deviation[j] = x[i][j]-path[i][j]; // x-path
+      domain->minimum_image(deviation);
+      for(int j=0;j<3;j++) array[i][j] += deviation[j];
+    }
+
+  // done if irepeat < nrepeat
+  // else reset irepeat and nvalid
+
+  irepeat++;
+  if (irepeat < nrepeat) {
+    nvalid += nevery;
+    //modify->addstep_compute(nvalid);
+    return;
+  }
+
+  irepeat = 0;
+  nvalid = ntimestep+peratom_freq - (nrepeat-1)*nevery;
+  //modify->addstep_compute(nvalid);
+
+  if (array == NULL) return;
+
+  // average the final result for the Nfreq timestep
+  double repeat = nrepeat;
+  for (i = 0; i < nlocal; i++)
+    for (m = 0; m < nvalues; m++)
+      array[i][m] /= repeat;
+}
+
+/* ----------------------------------------------------------------------
+  return array value - need to MPI_reduce??
+------------------------------------------------------------------------- */
+
+double FixAveDeviation::compute_array(int i,int j) {
+  return array[i][j];
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double FixAveDeviation::memory_usage()
+{
+  double bytes;
+  bytes = atom->nmax*nvalues * sizeof(double);
+  return bytes;
+}
+
+/* ----------------------------------------------------------------------
+   allocate atom-based array
+------------------------------------------------------------------------- */
+
+void FixAveDeviation::grow_arrays(int nmax)
+{
+  memory->grow(array,nmax,nvalues,"fix_ave/deviation:array");
+  array_atom = array;
+  if (array) vector_atom = array[0];
+  else vector_atom = NULL;
+}
+
+/* ----------------------------------------------------------------------
+   copy values within local atom-based array
+------------------------------------------------------------------------- */
+
+void FixAveDeviation::copy_arrays(int i, int j, int delflag)
+{
+  for (int m = 0; m < nvalues; m++)
+    array[j][m] = array[i][m];
+}
+
+/* ----------------------------------------------------------------------
+   pack values in local atom-based array for exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixAveDeviation::pack_exchange(int i, double *buf)
+{
+  for (int m = 0; m < nvalues; m++) buf[m] = array[i][m];
+  return nvalues;
+}
+
+/* ----------------------------------------------------------------------
+   unpack values in local atom-based array from exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixAveDeviation::unpack_exchange(int nlocal, double *buf)
+{
+  for (int m = 0; m < nvalues; m++) array[nlocal][m] = buf[m];
+  return nvalues;
+}
+
+/* ----------------------------------------------------------------------
+   calculate nvalid = next step on which end_of_step does something
+   can be this timestep if multiple of nfreq and nrepeat = 1
+   else backup from next multiple of nfreq
+------------------------------------------------------------------------- */
+
+bigint FixAveDeviation::nextvalid()
+{
+  bigint nvalid = (update->ntimestep/peratom_freq)*peratom_freq + peratom_freq;
+  if (nvalid-peratom_freq == update->ntimestep && nrepeat == 1)
+    nvalid = update->ntimestep;
+  else
+    nvalid -= (nrepeat-1)*nevery;
+  if (nvalid < update->ntimestep) nvalid += peratom_freq;
+  return nvalid;
+}
diff -ruN src/USER-PAFI/fix_ave_deviation.h clean_src/USER-PAFI/fix_ave_deviation.h
--- src/USER-PAFI/fix_ave_deviation.h	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/fix_ave_deviation.h	2018-11-22 17:56:09.906560638 +0100
@@ -0,0 +1,71 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(ave/deviation,FixAveDeviation)
+
+#else
+
+#ifndef LMP_FIX_AVE_DEVIATION_H
+#define LMP_FIX_AVE_DEVIATION_H
+
+#include <cstdio>
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class FixAveDeviation : public Fix {
+ public:
+  FixAveDeviation(class LAMMPS *, int, char **);
+  ~FixAveDeviation();
+  int setmask();
+  void init();
+  void setup(int);
+  void end_of_step();
+
+  double memory_usage();
+  void grow_arrays(int);
+  void copy_arrays(int, int, int);
+  int pack_exchange(int, double *);
+  int unpack_exchange(int, double *);
+
+  double compute_array(int,int);
+
+ private:
+  int nvalues;
+  int nrepeat,irepeat;
+  bigint nvalid,nvalid_last;
+  double **array;
+  bigint nextvalid();
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Invalid timestep reset for fix ave/deviation
+
+Resetting the timestep has invalidated the sequence of timesteps this
+fix needs to process.
+
+*/
diff -ruN src/USER-PAFI/fix_hp.cpp clean_src/USER-PAFI/fix_hp.cpp
--- src/USER-PAFI/fix_hp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/fix_hp.cpp	2018-11-22 17:56:09.902560588 +0100
@@ -0,0 +1,630 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+/* ------------------------------------------------------------------------
+   Contributing authors: Thomas Swinburne (CNRS & CINaM, Marseille, France)
+
+   Please cite the related publication:
+   T.D. Swinburne and M.-C. Marinica, Unsupervised calculation of free energy barriers in large crystalline systems, Physical Review Letters 2018
+------------------------------------------------------------------------- */
+
+
+#include <mpi.h>
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include "fix_hp.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "atom_vec_ellipsoid.h"
+#include "force.h"
+#include "update.h"
+#include "modify.h"
+#include "compute.h"
+#include "domain.h"
+#include "region.h"
+#include "respa.h"
+#include "comm.h"
+#include "input.h"
+#include "variable.h"
+#include "random_mars.h"
+#include "memory.h"
+#include "error.h"
+#include "group.h"
+
+
+
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{NONE,CONSTANT,EQUAL,ATOM};
+
+/* ---------------------------------------------------------------------- */
+
+FixHP::FixHP(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), idregion(NULL), random(NULL)
+{
+  if (narg < 5) error->all(FLERR,"Illegal fix hp command");
+
+  if (!atom->pafi_flag) error->all(FLERR,"Fix hp requires atom_style pafi or pafipath");
+
+  dynamic_group_allow = 1;
+  vector_flag = 1;
+  size_vector = 4;
+  global_freq = 1;
+  extvector = 0;
+  od_flag = 0;
+  com_flag = 0;
+
+  respa_level_support = 1;
+  ilevel_respa = nlevels_respa = 0;
+
+  temperature = force->numeric(FLERR,arg[3]);
+  t_period = force->numeric(FLERR,arg[4]);
+  seed = force->inumeric(FLERR,arg[5]);
+  // TODO UNITS
+  gamma = 1. / t_period / force->ftm2v;
+  sqrtD = sqrt(1.) * sqrt(24.0*force->boltz/t_period/update->dt/force->mvv2e*temperature) / force->ftm2v;
+
+  // optional args
+  iregion = -1;
+  idregion = NULL;
+  int iarg = 6;
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"region") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix hp command");
+      iregion = domain->find_region(arg[iarg+1]);
+      if (iregion == -1)
+        error->all(FLERR,"Region ID for fix hp does not exist");
+      int n = strlen(arg[iarg+1]) + 1;
+      idregion = new char[n];
+      strcpy(idregion,arg[iarg+1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg],"overdamped") == 0) {
+      od_flag = force->inumeric(FLERR,arg[iarg+1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg],"com") == 0) {
+      com_flag = force->inumeric(FLERR,arg[iarg+1]);
+      iarg += 2;
+    } else error->all(FLERR,"Illegal fix hp command");
+  }
+  force_flag = 0;
+
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i=0; i<5; i++) {
+    proj[i] = 0.0;
+    proj_all[i] = 0.0;
+  }
+  for(int i=0; i<4; i++) {
+    results[i] = 0.0;
+    results_all[i] = 0.0;
+  }
+  maxatom = 1;
+  memory->create(h,maxatom,3,"fixhp:h");
+
+  // initialize Marsaglia RNG with processor-unique seed
+  random = new RanMars(lmp,seed + comm->me);
+
+  // nve
+  dynamic_group_allow = 1;
+  time_integrate = 1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixHP::~FixHP()
+{
+  if (copymode) return;
+  delete random;
+  delete [] idregion;
+  memory->destroy(h);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixHP::setmask()
+{
+  int mask = 0;
+  mask |= POST_FORCE;
+  mask |= POST_FORCE_RESPA;
+  mask |= MIN_POST_FORCE;
+  mask |= INITIAL_INTEGRATE;
+  // nve
+  mask |= FINAL_INTEGRATE;
+  mask |= INITIAL_INTEGRATE_RESPA;
+  mask |= FINAL_INTEGRATE_RESPA;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::init()
+{
+  // set index and check validity of region
+  // nve
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+
+  if (iregion >= 0) {
+    iregion = domain->find_region(idregion);
+    if (iregion == -1)
+      error->all(FLERR,"Region ID for fix hp does not exist");
+  }
+
+  if (strstr(update->integrate_style,"respa")) {
+    step_respa = ((Respa *) update->integrate)->step; // nve
+    nlevels_respa = ((Respa *) update->integrate)->nlevels;
+    if (respa_level >= 0) ilevel_respa = MIN(respa_level,nlevels_respa-1);
+    else ilevel_respa = nlevels_respa-1;
+  }
+
+}
+
+void FixHP::setup(int vflag)
+{
+  if (strstr(update->integrate_style,"verlet"))
+    post_force(vflag);
+  else
+    for (int ilevel = 0; ilevel < nlevels_respa; ilevel++) {
+      ((Respa *) update->integrate)->copy_flevel_f(ilevel);
+      post_force_respa(vflag,ilevel,0);
+      ((Respa *) update->integrate)->copy_f_flevel(ilevel);
+    }
+}
+
+void FixHP::min_setup(int vflag)
+{
+  post_force(vflag);
+}
+
+
+void FixHP::post_force(int vflag)
+{
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  // update region if necessary
+
+  Region *region = NULL;
+  if (iregion >= 0) {
+    region = domain->regions[iregion];
+    region->prematch();
+  }
+  // reallocate norm array if necessary
+  if (atom->nmax > maxatom) {
+    maxatom = atom->nmax;
+    memory->destroy(h);
+    memory->create(h,maxatom,3,"fixhp:h");
+  }
+
+  double **path = atom->path;
+  double **norm = atom->norm;
+  double **dnorm = atom->dnorm;
+
+  double xum=0.;
+
+  // proj 0,1,2 = f.n, v.n, h.n
+  // proj 3,4,5 = psi, f.n**2, f*(1-psi)
+  // c_v 0,1,2 = fxcom, fycom, fzcom etc
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i = 0; i < 5; i++) {
+    proj[i] = 0.;
+    proj_all[i] = 0.;
+  }
+
+  double deviation[3] = {0.,0.,0.};
+
+  double fn;
+
+  force_flag=0;
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+      h[i][0] = random->uniform() - 0.5;
+      h[i][1] = random->uniform() - 0.5;
+      h[i][2] = random->uniform() - 0.5;
+
+      proj[0] += f[i][0] * norm[i][0]; // f.n
+      proj[0] += f[i][1] * norm[i][1]; // f.n
+      proj[0] += f[i][2] * norm[i][2]; // f.n
+
+      proj[1] += v[i][0] * norm[i][0]; // v.n
+      proj[1] += v[i][1] * norm[i][1]; // v.n
+      proj[1] += v[i][2] * norm[i][2]; // v.n
+
+      proj[2] += h[i][0] * norm[i][0]; // h.n
+      proj[2] += h[i][1] * norm[i][1]; // h.n
+      proj[2] += h[i][2] * norm[i][2]; // h.n
+
+      deviation[0] = x[i][0]-path[i][0]; // x-path
+      deviation[1] = x[i][1]-path[i][1]; // x-path
+      deviation[2] = x[i][2]-path[i][2]; // x-path
+      domain->minimum_image(deviation);
+
+      proj[3] += dnorm[i][0]*deviation[0]; // (x-path).dn/nn = psi
+      proj[3] += dnorm[i][1]*deviation[1]; // (x-path).dn/nn = psi
+      proj[3] += dnorm[i][2]*deviation[2]; // (x-path).dn/nn = psi
+
+      proj[4] += norm[i][0]*deviation[0]; // (x-path).dn/nn = psi
+      proj[4] += norm[i][1]*deviation[1]; // (x-path).dn/nn = psi
+      proj[4] += norm[i][2]*deviation[2]; // (x-path).dn/nn = psi
+
+    }
+  }
+
+  if(com_flag == 0){
+    c_v[9] += 1.0;
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+        c_v[0] += f[i][0];
+        c_v[1] += f[i][1];
+        c_v[2] += f[i][2];
+
+        c_v[3] += v[i][0];
+        c_v[4] += v[i][1];
+        c_v[5] += v[i][2];
+
+        c_v[6] += h[i][0];
+        c_v[7] += h[i][1];
+        c_v[8] += h[i][2];
+
+        c_v[9] += 1.0;
+      }
+  }
+  MPI_Allreduce(proj,proj_all,5,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(c_v,c_v_all,10,MPI_DOUBLE,MPI_SUM,world);
+
+  // results - f.n*(1-psi), (f.n)^2*(1-psi)^2, 1-psi
+  if(comm->me ==0) {
+    results_all[0] = proj_all[0] * (1.-proj_all[3]);
+    results_all[1] = results_all[0] * results_all[0];
+    results_all[2] = 1.-proj_all[3];
+    results_all[3] = proj_all[4];
+  }
+  MPI_Bcast(results_all,4,MPI_DOUBLE,0,world);
+  force_flag = 1;
+
+  for (int i = 0; i < nlocal; i++){
+    if (mask[i] & groupbit) {
+      if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+      f[i][0] -= proj_all[0] * norm[i][0] + c_v_all[0]/c_v_all[9];
+      f[i][1] -= proj_all[0] * norm[i][1] + c_v_all[1]/c_v_all[9];
+      f[i][2] -= proj_all[0] * norm[i][2] + c_v_all[2]/c_v_all[9];
+
+      v[i][0] -= proj_all[1] * norm[i][0] + c_v_all[3]/c_v_all[9];
+      v[i][1] -= proj_all[1] * norm[i][1] + c_v_all[4]/c_v_all[9];
+      v[i][2] -= proj_all[1] * norm[i][2] + c_v_all[5]/c_v_all[9];
+
+      h[i][0] -= proj_all[2] * norm[i][0] + c_v_all[6]/c_v_all[9];
+      h[i][1] -= proj_all[2] * norm[i][1] + c_v_all[7]/c_v_all[9];
+      h[i][2] -= proj_all[2] * norm[i][2] + c_v_all[8]/c_v_all[9];
+    }
+  }
+
+
+  if (od_flag == 0) {
+    for (int i = 0; i < nlocal; i++){
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+        if(rmass) mass_f = sqrt(rmass[i]);
+        else mass_f = sqrt(mass[type[i]]);
+
+        f[i][0] += -gamma * mass_f * mass_f * v[i][0] + sqrtD * mass_f * h[i][0];
+        f[i][1] += -gamma * mass_f * mass_f * v[i][1] + sqrtD * mass_f * h[i][1];
+        f[i][2] += -gamma * mass_f * mass_f * v[i][2] + sqrtD * mass_f * h[i][2];
+      }
+    }
+  } else {
+    for (int i = 0; i < nlocal; i++){
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+        if(rmass) mass_f = sqrt(rmass[i]);
+        else mass_f = sqrt(mass[type[i]]);
+
+        f[i][0] += sqrtD * h[i][0] * mass_f;
+        f[i][1] += sqrtD * h[i][1] * mass_f;
+        f[i][2] += sqrtD * h[i][2] * mass_f;
+
+
+        f[i][0] /=  gamma * mass_f * mass_f;
+        f[i][1] /=  gamma * mass_f * mass_f;
+        f[i][2] /=  gamma * mass_f * mass_f;
+
+      }
+    }
+  }
+}
+
+void FixHP::post_force_respa(int vflag, int ilevel, int iloop)
+{
+  // set force to desired value on requested level, 0.0 on other levels
+
+  if (ilevel == ilevel_respa) post_force(vflag);
+  else {
+    Region *region = NULL;
+    if (iregion >= 0) {
+      region = domain->regions[iregion];
+      region->prematch();
+    }
+    double **x = atom->x;
+    double **f = atom->f;
+    int *mask = atom->mask;
+    int nlocal = atom->nlocal;
+
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+        for (int k = 0; k < 3; k++) f[i][k] = 0.0;
+      }
+  }
+};
+
+void FixHP::min_post_force(int vflag)
+{
+  post_force(vflag);
+};
+
+double FixHP::compute_vector(int n)
+{
+  return results_all[n];
+};
+
+
+
+void FixHP::initial_integrate(int vflag)
+{
+  double dtfm;
+
+  // update v and x of atoms in group
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
+
+
+  double **norm = atom->norm;
+
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i = 0; i < 5; i++) {
+    proj[i] = 0.;
+    proj_all[i] = 0.;
+  }
+
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      proj[0] += f[i][0] * norm[i][0]; // f.n
+      proj[0] += f[i][1] * norm[i][1]; // f.n
+      proj[0] += f[i][2] * norm[i][2]; // f.n
+
+      proj[1] += v[i][0] * norm[i][0]; // v.n
+      proj[1] += v[i][1] * norm[i][1]; // v.n
+      proj[1] += v[i][2] * norm[i][2]; // v.n
+    }
+  }
+  if(com_flag == 0){
+    c_v[9] += 1.0;
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+
+        c_v[0] += v[i][0];
+        c_v[1] += v[i][1];
+        c_v[2] += v[i][2];
+
+        c_v[3] += f[i][0];
+        c_v[4] += f[i][1];
+        c_v[5] += f[i][2];
+
+        c_v[9] += 1.0;
+      }
+  }
+
+
+  MPI_Allreduce(proj,proj_all,5,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(c_v,c_v_all,10,MPI_DOUBLE,MPI_SUM,world);
+
+  if (od_flag == 0){
+    if (rmass) {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / rmass[i];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+          x[i][0] += dtv * (v[i][0]-norm[i][0]*proj_all[1] - c_v_all[0]/c_v_all[9]);
+          x[i][1] += dtv * (v[i][1]-norm[i][1]*proj_all[1] - c_v_all[1]/c_v_all[9]);
+          x[i][2] += dtv * (v[i][2]-norm[i][2]*proj_all[1] - c_v_all[2]/c_v_all[9]);
+        }
+    } else {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / mass[type[i]];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+          x[i][0] += dtv * (v[i][0]-norm[i][0]*proj_all[1] - c_v_all[0]/c_v_all[9]);
+          x[i][1] += dtv * (v[i][1]-norm[i][1]*proj_all[1] - c_v_all[1]/c_v_all[9]);
+          x[i][2] += dtv * (v[i][2]-norm[i][2]*proj_all[1] - c_v_all[2]/c_v_all[9]);
+        }
+    }
+  } else {
+    if (rmass) {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / rmass[i];
+          v[i][0] = 0.;
+          v[i][1] = 0.;
+          v[i][2] = 0.;
+          x[i][0] += dtv * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          x[i][1] += dtv * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          x[i][2] += dtv * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    } else {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / mass[type[i]];
+          v[i][0] = 0.;
+          v[i][1] = 0.;
+          v[i][2] = 0.;
+          x[i][0] += dtv * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          x[i][1] += dtv * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          x[i][2] += dtv * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    }
+  }
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::final_integrate()
+{
+  double dtfm;
+
+  // update v of atoms in group
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
+
+  double **norm = atom->norm;
+
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i = 0; i < 5; i++) {
+    proj[i] = 0.;
+    proj_all[i] = 0.;
+  }
+  for (int i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit) {
+      proj[0] += f[i][0] * norm[i][0]; // f.n
+      proj[0] += f[i][1] * norm[i][1]; // f.n
+      proj[0] += f[i][2] * norm[i][2]; // f.n
+    }
+  if(com_flag == 0){
+    c_v[9] += 1.0;
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        c_v[3] += f[i][0];
+        c_v[4] += f[i][1];
+        c_v[5] += f[i][2];
+        c_v[9] += 1.0;
+      }
+  }
+
+  MPI_Allreduce(proj,proj_all,5,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(c_v,c_v_all,10,MPI_DOUBLE,MPI_SUM,world);
+
+  if (od_flag == 0){
+    if (rmass) {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / rmass[i];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    } else {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / mass[type[i]];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    }
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        v[i][0] = 0.;
+        v[i][1] = 0.;
+        v[i][2] = 0.;
+      }
+  }
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::initial_integrate_respa(int vflag, int ilevel, int iloop)
+{
+  dtv = step_respa[ilevel];
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+
+  // innermost level - NVE update of v and x
+  // all other levels - NVE update of v
+
+  if (ilevel == 0) initial_integrate(vflag);
+  else final_integrate();
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::final_integrate_respa(int ilevel, int iloop)
+{
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+  final_integrate();
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::reset_dt()
+{
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+};
+
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double FixHP::memory_usage()
+{
+  double bytes = 0.0;
+  bytes = maxatom*3 * sizeof(double);
+  return bytes;
+};
diff -ruN src/USER-PAFI/fix_hp.h clean_src/USER-PAFI/fix_hp.h
--- src/USER-PAFI/fix_hp.h	1970-01-01 01:00:00.000000000 +0100
+++ clean_src/USER-PAFI/fix_hp.h	2018-11-22 17:56:09.902560588 +0100
@@ -0,0 +1,101 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(hp,FixHP)
+
+#else
+
+#ifndef LMP_FIX_HP_H
+#define LMP_FIX_HP_H
+
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class FixHP : public Fix {
+ public:
+  FixHP(class LAMMPS *, int, char **);
+  virtual ~FixHP();
+  int setmask();
+  virtual void init();
+
+  void setup(int);
+  void min_setup(int);
+  virtual void post_force(int);
+
+  void post_force_respa(int, int, int);
+  void min_post_force(int);
+  double compute_vector(int);
+  // nve
+  virtual void initial_integrate(int);
+  virtual void final_integrate();
+  virtual void initial_integrate_respa(int, int, int);
+  virtual void final_integrate_respa(int, int);
+  virtual void reset_dt();
+
+  double memory_usage();
+
+ protected:
+  int varflag,iregion;
+  char *idregion;
+
+  double proj[5], proj_all[5]; // f,v,h, psi
+  double results[4], results_all[4]; // f.n, (f.n)**2, psi, dx.n
+  double c_v[10],c_v_all[10];
+
+  double temperature,gamma,sqrtD,t_period,local_norm,mass_f;
+  int force_flag,od_flag,com_flag;
+  int nlevels_respa,ilevel_respa;
+  int maxatom;
+  class RanMars *random;
+  int seed;
+  double **h;
+  // nve
+  double dtv,dtf;
+  double *step_respa;
+  int mass_require;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Region ID for fix setforce does not exist
+
+Self-explanatory.
+
+E: Variable name for fix setforce does not exist
+
+Self-explanatory.
+
+E: Variable for fix setforce is invalid style
+
+Only equal-style variables can be used.
+
+E: Cannot use non-zero forces in an energy minimization
+
+Fix setforce cannot be used in this manner.  Use fix addforce
+instead.
+
+*/
