Common subdirectories: src/ASPHERE and src_pafi/ASPHERE
diff -uN src/atom.cpp src_pafi/atom.cpp
--- src/atom.cpp	2018-11-13 15:33:50.822074235 +0100
+++ src_pafi/atom.cpp	2018-11-13 15:33:29.865752803 +0100
@@ -76,7 +76,8 @@
   type = mask = NULL;
   image = NULL;
   x = v = f = NULL;
-
+  norm = dnorm = path = trueforce = NULL;
+  
   molecule = NULL;
   molindex = molatom = NULL;
   q = NULL;
@@ -99,7 +100,7 @@
   // SPIN package
 
   sp = fm = NULL;
-  
+
   // USER-DPD
 
   uCond = uMech = uChem = uCG = uCGnew = NULL;
@@ -1516,7 +1517,7 @@
    called from reading of input script
 ------------------------------------------------------------------------- */
 
-void Atom::set_mass(const char *file, int line, int narg, char **arg)
+void Atom::set_mass(const char *file, int line, int /*narg*/, char **arg)
 {
   if (mass == NULL) error->all(file,line,"Cannot set mass for this atom style");
 
@@ -2182,6 +2183,10 @@
   if (strcmp(name,"x") == 0) return (void *) x;
   if (strcmp(name,"v") == 0) return (void *) v;
   if (strcmp(name,"f") == 0) return (void *) f;
+  if (strcmp(name,"norm") == 0) return (void *) norm;
+  if (strcmp(name,"dnorm") == 0) return (void *) dnorm;
+  if (strcmp(name,"path") == 0) return (void *) path;
+  if (strcmp(name,"trueforce") == 0) return (void *) trueforce;
   if (strcmp(name,"molecule") == 0) return (void *) molecule;
   if (strcmp(name,"q") == 0) return (void *) q;
   if (strcmp(name,"mu") == 0) return (void *) mu;
diff -uN src/atom.h src_pafi/atom.h
--- src/atom.h	2018-11-13 15:33:50.822074235 +0100
+++ src_pafi/atom.h	2018-11-13 15:33:27.293711185 +0100
@@ -51,7 +51,7 @@
   tagint *tag;
   int *type,*mask;
   imageint *image;
-  double **x,**v,**f;
+  double **x,**v,**f, **norm, **dnorm, **path, **trueforce;
 
   tagint *molecule;
   int *molindex,*molatom;
Common subdirectories: src/BODY and src_pafi/BODY
Common subdirectories: src/CLASS2 and src_pafi/CLASS2
Common subdirectories: src/COLLOID and src_pafi/COLLOID
Common subdirectories: src/COMPRESS and src_pafi/COMPRESS
Common subdirectories: src/CORESHELL and src_pafi/CORESHELL
Common subdirectories: src/DEPEND and src_pafi/DEPEND
Common subdirectories: src/DIPOLE and src_pafi/DIPOLE
diff -uN src/fix_hp.cpp src_pafi/fix_hp.cpp
--- src/fix_hp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ src_pafi/fix_hp.cpp	2018-11-13 15:33:15.897520815 +0100
@@ -0,0 +1,619 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <mpi.h>
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include "fix_hp.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "atom_vec_ellipsoid.h"
+#include "force.h"
+#include "update.h"
+#include "modify.h"
+#include "compute.h"
+#include "domain.h"
+#include "region.h"
+#include "respa.h"
+#include "comm.h"
+#include "input.h"
+#include "variable.h"
+#include "random_mars.h"
+#include "memory.h"
+#include "error.h"
+#include "group.h"
+
+
+
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{NONE,CONSTANT,EQUAL,ATOM};
+
+/* ---------------------------------------------------------------------- */
+
+FixHP::FixHP(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), idregion(NULL), random(NULL)
+{
+  if (narg < 5) error->all(FLERR,"Illegal fix hp command");
+
+  dynamic_group_allow = 1;
+  vector_flag = 1;
+  size_vector = 3;
+  global_freq = 1;
+  extvector = 0;
+  od_flag = 0;
+  com_flag = 0;
+
+  respa_level_support = 1;
+  ilevel_respa = nlevels_respa = 0;
+
+  temperature = force->numeric(FLERR,arg[3]);
+  t_period = force->numeric(FLERR,arg[4]);
+  seed = force->inumeric(FLERR,arg[5]);
+  gamma = 100. / t_period / force->ftm2v;
+  sqrtD = sqrt(100.) * sqrt(24.0*force->boltz/t_period/update->dt/force->mvv2e*temperature) / force->ftm2v;
+
+  // optional args
+  iregion = -1;
+  idregion = NULL;
+  int iarg = 6;
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"region") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix hp command");
+      iregion = domain->find_region(arg[iarg+1]);
+      if (iregion == -1)
+        error->all(FLERR,"Region ID for fix hp does not exist");
+      int n = strlen(arg[iarg+1]) + 1;
+      idregion = new char[n];
+      strcpy(idregion,arg[iarg+1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg],"overdamped") == 0) {
+      od_flag = force->inumeric(FLERR,arg[iarg+1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg],"com") == 0) {
+      com_flag = force->inumeric(FLERR,arg[iarg+1]);
+      iarg += 2;
+    } else error->all(FLERR,"Illegal fix hp command");
+  }
+  force_flag = 0;
+
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i=0; i<4; i++) {
+    proj[i] = 0.0;
+    proj_all[i] = 0.0;
+  }
+  
+  maxatom = 1;
+  memory->create(atom->norm,maxatom,3,"atom:norm");
+  memory->create(atom->dnorm,maxatom,3,"atom:dnorm");
+  memory->create(atom->path,maxatom,3,"atom:path");
+  memory->create(h,maxatom,3,"fixhp:h");
+
+  // initialize Marsaglia RNG with processor-unique seed
+  random = new RanMars(lmp,seed + comm->me);
+
+  // nve
+  dynamic_group_allow = 1;
+  time_integrate = 1;
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixHP::~FixHP()
+{
+  if (copymode) return;
+  delete random;
+  delete [] idregion;
+  memory->destroy(atom->norm);
+  memory->destroy(atom->dnorm);
+  memory->destroy(atom->path);
+  memory->destroy(h);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixHP::setmask()
+{
+  int mask = 0;
+  mask |= POST_FORCE;
+  mask |= POST_FORCE_RESPA;
+  mask |= MIN_POST_FORCE;
+  mask |= INITIAL_INTEGRATE;
+  // nve
+  mask |= FINAL_INTEGRATE;
+  mask |= INITIAL_INTEGRATE_RESPA;
+  mask |= FINAL_INTEGRATE_RESPA;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::init()
+{
+  // set index and check validity of region
+  // nve
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+
+  if (iregion >= 0) {
+    iregion = domain->find_region(idregion);
+    if (iregion == -1)
+      error->all(FLERR,"Region ID for fix hp does not exist");
+  }
+
+  if (strstr(update->integrate_style,"respa")) {
+    step_respa = ((Respa *) update->integrate)->step; // nve
+    nlevels_respa = ((Respa *) update->integrate)->nlevels;
+    if (respa_level >= 0) ilevel_respa = MIN(respa_level,nlevels_respa-1);
+    else ilevel_respa = nlevels_respa-1;
+  }
+
+}
+
+void FixHP::setup(int vflag)
+{
+  if (strstr(update->integrate_style,"verlet"))
+    post_force(vflag);
+  else
+    for (int ilevel = 0; ilevel < nlevels_respa; ilevel++) {
+      ((Respa *) update->integrate)->copy_flevel_f(ilevel);
+      post_force_respa(vflag,ilevel,0);
+      ((Respa *) update->integrate)->copy_f_flevel(ilevel);
+    }
+}
+
+void FixHP::min_setup(int vflag)
+{
+  post_force(vflag);
+}
+
+
+void FixHP::post_force(int vflag)
+{
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  // update region if necessary
+
+  Region *region = NULL;
+  if (iregion >= 0) {
+    region = domain->regions[iregion];
+    region->prematch();
+  }
+  // reallocate norm array if necessary
+  if (atom->nmax > maxatom) {
+    maxatom = atom->nmax;
+    memory->destroy(atom->norm);
+    memory->create(atom->norm,maxatom,3,"atom:norm");
+    memory->destroy(atom->dnorm);
+    memory->create(atom->dnorm,maxatom,3,"atom:dnorm");
+    memory->destroy(atom->path);
+    memory->create(atom->path,maxatom,3,"atom:path");
+    memory->destroy(h);
+    memory->create(h,maxatom,3,"fixhp:h");
+  }
+  double **u = atom->path;
+  double **norm = atom->norm;
+  double **dnorm = atom->dnorm;
+
+  double xum=0.;
+
+  // proj 0,1,2 = f.n, v.n, h.n
+  // proj 3,4,5 = psi, f.n**2, f*(1-psi)
+
+  // c_v 0,1,2 = fxcom, fycom, fzcom etc
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i = 0; i < 4; i++) {
+    proj[i] = 0.;
+    proj_all[i] = 0.;
+  }
+
+  double deviation[3] = {0.,0.,0.};
+
+  force_flag=0;
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+      h[i][0] = random->uniform() - 0.5;
+      h[i][1] = random->uniform() - 0.5;
+      h[i][2] = random->uniform() - 0.5;
+
+      proj[0] += f[i][0] * norm[i][0]; // f.n
+      proj[0] += f[i][1] * norm[i][1]; // f.n
+      proj[0] += f[i][2] * norm[i][2]; // f.n
+
+      proj[1] += v[i][0] * norm[i][0]; // v.n
+      proj[1] += v[i][1] * norm[i][1]; // v.n
+      proj[1] += v[i][2] * norm[i][2]; // v.n
+
+      proj[2] += h[i][0] * norm[i][0]; // h.n
+      proj[2] += h[i][1] * norm[i][1]; // h.n
+      proj[2] += h[i][2] * norm[i][2]; // h.n
+
+      deviation[0] = x[i][0]-u[i][0]; // x-u
+      deviation[1] = x[i][1]-u[i][1]; // x-u
+      deviation[2] = x[i][2]-u[i][2]; // x-u
+      domain->minimum_image(deviation);
+
+      proj[3] += dnorm[i][0]*deviation[0]; // (x-u).dn/nn = psi
+      proj[3] += dnorm[i][1]*deviation[1]; // (x-u).dn/nn = psi
+      proj[3] += dnorm[i][2]*deviation[2]; // (x-u).dn/nn = psi
+
+    }
+  }
+
+  if(com_flag == 0){
+    c_v[9] += 1.0;
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+        c_v[0] += f[i][0];
+        c_v[1] += f[i][1];
+        c_v[2] += f[i][2];
+
+        c_v[3] += v[i][0];
+        c_v[4] += v[i][1];
+        c_v[5] += v[i][2];
+
+        c_v[6] += h[i][0];
+        c_v[7] += h[i][1];
+        c_v[8] += h[i][2];
+
+        c_v[9] += 1.0;
+      }
+  }
+
+  MPI_Allreduce(proj,proj_all,4,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(c_v,c_v_all,10,MPI_DOUBLE,MPI_SUM,world);
+
+  // results - f.n*(1-psi), (f.n)^2*(1-psi)^2, 1-psi
+  results[0] = proj_all[0] * (1.-proj_all[4]);
+  results[1] = results[0] * results[0];
+  results[2] = 1.-proj_all[4];
+  force_flag = 1;
+
+  for (int i = 0; i < nlocal; i++){
+    if (mask[i] & groupbit) {
+      if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+
+      f[i][0] -= proj_all[0] * norm[i][0] + c_v_all[0]/c_v_all[9];
+      f[i][1] -= proj_all[0] * norm[i][1] + c_v_all[1]/c_v_all[9];
+      f[i][2] -= proj_all[0] * norm[i][2] + c_v_all[2]/c_v_all[9];
+
+      v[i][0] -= proj_all[1] * norm[i][0] + c_v_all[3]/c_v_all[9];
+      v[i][1] -= proj_all[1] * norm[i][1] + c_v_all[4]/c_v_all[9];
+      v[i][2] -= proj_all[1] * norm[i][2] + c_v_all[5]/c_v_all[9];
+
+      h[i][0] -= proj_all[2] * norm[i][0] + c_v_all[6]/c_v_all[9];
+      h[i][1] -= proj_all[2] * norm[i][1] + c_v_all[7]/c_v_all[9];
+      h[i][2] -= proj_all[2] * norm[i][2] + c_v_all[8]/c_v_all[9];
+    }
+  }
+
+  if (od_flag == 0) {
+    for (int i = 0; i < nlocal; i++){
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+        f[i][0] += -gamma * v[i][0] + sqrtD * h[i][0];
+        f[i][1] += -gamma * v[i][1] + sqrtD * h[i][1];
+        f[i][2] += -gamma * v[i][2] + sqrtD * h[i][2];
+      }
+    }
+  } else {
+    for (int i = 0; i < nlocal; i++){
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+        f[i][0] += sqrtD * h[i][0];
+        f[i][1] += sqrtD * h[i][1];
+        f[i][2] += sqrtD * h[i][2];
+        f[i][0] /= gamma;
+        f[i][1] /= gamma;
+        f[i][2] /= gamma;
+      }
+    }
+  }
+}
+
+void FixHP::post_force_respa(int vflag, int ilevel, int iloop)
+{
+  // set force to desired value on requested level, 0.0 on other levels
+
+  if (ilevel == ilevel_respa) post_force(vflag);
+  else {
+    Region *region = NULL;
+    if (iregion >= 0) {
+      region = domain->regions[iregion];
+      region->prematch();
+    }
+    double **x = atom->x;
+    double **f = atom->f;
+    int *mask = atom->mask;
+    int nlocal = atom->nlocal;
+
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        if (region && !region->match(x[i][0],x[i][1],x[i][2])) continue;
+        for (int k = 0; k < 3; k++) f[i][k] = 0.0;
+      }
+  }
+};
+
+void FixHP::min_post_force(int vflag)
+{
+  post_force(vflag);
+};
+
+double FixHP::compute_vector(int n)
+{
+  // only sum across procs one time
+  /*if (force_flag == 0) {
+
+    for(int i=0; i<4; i++) proj_all[i] = 0.;
+    MPI_Allreduce(proj,proj_all,4,MPI_DOUBLE,MPI_SUM,world);
+    force_flag = 1;
+
+    results[0] = proj_all[0] * (1.-proj_all[3]);
+    results[1] = results[0] * results[0];
+    results[2] = 1.-proj_all[3];
+  }*/
+  return results[n];
+};
+
+
+
+void FixHP::initial_integrate(int vflag)
+{
+  double dtfm;
+
+  // update v and x of atoms in group
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
+
+
+  double **norm = atom->norm;
+
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i = 0; i < 4; i++) {
+    proj[i] = 0.;
+    proj_all[i] = 0.;
+  }
+
+  //force_flag = 0;
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      proj[0] += f[i][0] * norm[i][0]; // f.n
+      proj[0] += f[i][1] * norm[i][1]; // f.n
+      proj[0] += f[i][2] * norm[i][2]; // f.n
+
+      proj[1] += v[i][0] * norm[i][0]; // v.n
+      proj[1] += v[i][1] * norm[i][1]; // v.n
+      proj[1] += v[i][2] * norm[i][2]; // v.n
+    }
+  }
+  if(com_flag == 0){
+    c_v[9] += 1.0;
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+
+        c_v[0] += v[i][0];
+        c_v[1] += v[i][1];
+        c_v[2] += v[i][2];
+
+        c_v[3] += f[i][0];
+        c_v[4] += f[i][1];
+        c_v[5] += f[i][2];
+
+        c_v[9] += 1.0;
+      }
+  }
+
+  MPI_Allreduce(proj,proj_all,4,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(c_v,c_v_all,10,MPI_DOUBLE,MPI_SUM,world);
+
+  if (od_flag == 0){
+    if (rmass) {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / rmass[i];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+          x[i][0] += dtv * (v[i][0]-norm[i][0]*proj_all[1] - c_v_all[0]/c_v_all[9]);
+          x[i][1] += dtv * (v[i][1]-norm[i][1]*proj_all[1] - c_v_all[1]/c_v_all[9]);
+          x[i][2] += dtv * (v[i][2]-norm[i][2]*proj_all[1] - c_v_all[2]/c_v_all[9]);
+        }
+    } else {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / mass[type[i]];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+          x[i][0] += dtv * (v[i][0]-norm[i][0]*proj_all[1] - c_v_all[0]/c_v_all[9]);
+          x[i][1] += dtv * (v[i][1]-norm[i][1]*proj_all[1] - c_v_all[1]/c_v_all[9]);
+          x[i][2] += dtv * (v[i][2]-norm[i][2]*proj_all[1] - c_v_all[2]/c_v_all[9]);
+        }
+    }
+  } else {
+    if (rmass) {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / rmass[i];
+          v[i][0] = 0.;
+          v[i][1] = 0.;
+          v[i][2] = 0.;
+          x[i][0] += dtv * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          x[i][1] += dtv * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          x[i][2] += dtv * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    } else {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / mass[type[i]];
+          v[i][0] = 0.;
+          v[i][1] = 0.;
+          v[i][2] = 0.;
+          x[i][0] += dtv * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          x[i][1] += dtv * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          x[i][2] += dtv * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    }
+  }
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::final_integrate()
+{
+  double dtfm;
+
+  // update v of atoms in group
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
+
+  double **norm = atom->norm;
+
+  for(int i = 0; i < 10; i++) {
+    c_v[i] = 0.;
+    c_v_all[i] = 0.;
+  }
+  for(int i = 0; i < 4; i++) {
+    proj[i] = 0.;
+    proj_all[i] = 0.;
+  }
+  //force_flag = 0;
+  for (int i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit) {
+      proj[0] += f[i][0] * norm[i][0]; // f.n
+      proj[0] += f[i][1] * norm[i][1]; // f.n
+      proj[0] += f[i][2] * norm[i][2]; // f.n
+    }
+  if(com_flag == 0){
+    c_v[9] += 1.0;
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        c_v[3] += f[i][0];
+        c_v[4] += f[i][1];
+        c_v[5] += f[i][2];
+        c_v[9] += 1.0;
+      }
+  }
+  MPI_Allreduce(proj,proj_all,4,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(c_v,c_v_all,10,MPI_DOUBLE,MPI_SUM,world);
+
+
+  if (od_flag == 0){
+    if (rmass) {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / rmass[i];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    } else {
+      for (int i = 0; i < nlocal; i++)
+        if (mask[i] & groupbit) {
+          dtfm = dtf / mass[type[i]];
+          v[i][0] += dtfm * (f[i][0]-norm[i][0]*proj_all[0] - c_v_all[3]/c_v_all[9]);
+          v[i][1] += dtfm * (f[i][1]-norm[i][1]*proj_all[0] - c_v_all[4]/c_v_all[9]);
+          v[i][2] += dtfm * (f[i][2]-norm[i][2]*proj_all[0] - c_v_all[5]/c_v_all[9]);
+        }
+    }
+  } else {
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        v[i][0] = 0.;
+        v[i][1] = 0.;
+        v[i][2] = 0.;
+      }
+  }
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::initial_integrate_respa(int vflag, int ilevel, int iloop)
+{
+  dtv = step_respa[ilevel];
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+
+  // innermost level - NVE update of v and x
+  // all other levels - NVE update of v
+
+  if (ilevel == 0) initial_integrate(vflag);
+  else final_integrate();
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::final_integrate_respa(int ilevel, int iloop)
+{
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+  final_integrate();
+};
+
+/* ---------------------------------------------------------------------- */
+
+void FixHP::reset_dt()
+{
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+};
+
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double FixHP::memory_usage()
+{
+  double bytes = 0.0;
+  bytes = maxatom*3 * sizeof(double);
+  return bytes;
+};
diff -uN src/fix_hp.h src_pafi/fix_hp.h
--- src/fix_hp.h	1970-01-01 01:00:00.000000000 +0100
+++ src_pafi/fix_hp.h	2018-11-13 15:33:15.897520815 +0100
@@ -0,0 +1,101 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(hp,FixHP)
+
+#else
+
+#ifndef LMP_FIX_HP_H
+#define LMP_FIX_HP_H
+
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class FixHP : public Fix {
+ public:
+  FixHP(class LAMMPS *, int, char **);
+  virtual ~FixHP();
+  int setmask();
+  virtual void init();
+
+  void setup(int);
+  void min_setup(int);
+  virtual void post_force(int);
+
+  void post_force_respa(int, int, int);
+  void min_post_force(int);
+  double compute_vector(int);
+  // nve
+  virtual void initial_integrate(int);
+  virtual void final_integrate();
+  virtual void initial_integrate_respa(int, int, int);
+  virtual void final_integrate_respa(int, int);
+  virtual void reset_dt();
+
+  double memory_usage();
+
+ protected:
+  int varflag,iregion;
+  char *idregion;
+
+  double proj[4], proj_all[4]; // f,v,h, psi
+  double results[3]; // f.n, (f.n)**2, psi
+  double c_v[10],c_v_all[10];
+
+  double temperature,gamma,sqrtD,t_period,local_norm;
+  int force_flag,od_flag,com_flag;
+  int nlevels_respa,ilevel_respa;
+  int maxatom;
+  class RanMars *random;
+  int seed;
+  double **h;
+  // nve
+  double dtv,dtf;
+  double *step_respa;
+  int mass_require;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Region ID for fix setforce does not exist
+
+Self-explanatory.
+
+E: Variable name for fix setforce does not exist
+
+Self-explanatory.
+
+E: Variable for fix setforce is invalid style
+
+Only equal-style variables can be used.
+
+E: Cannot use non-zero forces in an energy minimization
+
+Fix setforce cannot be used in this manner.  Use fix addforce
+instead.
+
+*/
Common subdirectories: src/GPU and src_pafi/GPU
Common subdirectories: src/GRANULAR and src_pafi/GRANULAR
Common subdirectories: src/KIM and src_pafi/KIM
Common subdirectories: src/KOKKOS and src_pafi/KOKKOS
Common subdirectories: src/KSPACE and src_pafi/KSPACE
Common subdirectories: src/LATTE and src_pafi/LATTE
Common subdirectories: src/MAKE and src_pafi/MAKE
Common subdirectories: src/MANYBODY and src_pafi/MANYBODY
Common subdirectories: src/MC and src_pafi/MC
Common subdirectories: src/MEAM and src_pafi/MEAM
Common subdirectories: src/MISC and src_pafi/MISC
Common subdirectories: src/MOLECULE and src_pafi/MOLECULE
Common subdirectories: src/MPIIO and src_pafi/MPIIO
Common subdirectories: src/MSCG and src_pafi/MSCG
Common subdirectories: src/OPT and src_pafi/OPT
Common subdirectories: src/PERI and src_pafi/PERI
Common subdirectories: src/POEMS and src_pafi/POEMS
Common subdirectories: src/PYTHON and src_pafi/PYTHON
Common subdirectories: src/QEQ and src_pafi/QEQ
Common subdirectories: src/REAX and src_pafi/REAX
Common subdirectories: src/REPLICA and src_pafi/REPLICA
Common subdirectories: src/RIGID and src_pafi/RIGID
Common subdirectories: src/SHOCK and src_pafi/SHOCK
Common subdirectories: src/SNAP and src_pafi/SNAP
Common subdirectories: src/SPIN and src_pafi/SPIN
Common subdirectories: src/SRD and src_pafi/SRD
Common subdirectories: src/STUBS and src_pafi/STUBS
Common subdirectories: src/USER-ATC and src_pafi/USER-ATC
Common subdirectories: src/USER-AWPMD and src_pafi/USER-AWPMD
Common subdirectories: src/USER-BOCS and src_pafi/USER-BOCS
Common subdirectories: src/USER-CGDNA and src_pafi/USER-CGDNA
Common subdirectories: src/USER-CGSDK and src_pafi/USER-CGSDK
Common subdirectories: src/USER-COLVARS and src_pafi/USER-COLVARS
Common subdirectories: src/USER-DIFFRACTION and src_pafi/USER-DIFFRACTION
Common subdirectories: src/USER-DPD and src_pafi/USER-DPD
Common subdirectories: src/USER-DRUDE and src_pafi/USER-DRUDE
Common subdirectories: src/USER-EFF and src_pafi/USER-EFF
Common subdirectories: src/USER-FEP and src_pafi/USER-FEP
Common subdirectories: src/USER-H5MD and src_pafi/USER-H5MD
Common subdirectories: src/USER-INTEL and src_pafi/USER-INTEL
Common subdirectories: src/USER-LB and src_pafi/USER-LB
Common subdirectories: src/USER-MANIFOLD and src_pafi/USER-MANIFOLD
Common subdirectories: src/USER-MEAMC and src_pafi/USER-MEAMC
Common subdirectories: src/USER-MESO and src_pafi/USER-MESO
Common subdirectories: src/USER-MGPT and src_pafi/USER-MGPT
Common subdirectories: src/USER-MISC and src_pafi/USER-MISC
Common subdirectories: src/USER-MOFFF and src_pafi/USER-MOFFF
Common subdirectories: src/USER-MOLFILE and src_pafi/USER-MOLFILE
Common subdirectories: src/USER-NETCDF and src_pafi/USER-NETCDF
Common subdirectories: src/USER-OMP and src_pafi/USER-OMP
Common subdirectories: src/USER-PHONON and src_pafi/USER-PHONON
Common subdirectories: src/USER-QMMM and src_pafi/USER-QMMM
Common subdirectories: src/USER-QTB and src_pafi/USER-QTB
Common subdirectories: src/USER-QUIP and src_pafi/USER-QUIP
Common subdirectories: src/USER-REAXC and src_pafi/USER-REAXC
Common subdirectories: src/USER-SMD and src_pafi/USER-SMD
Common subdirectories: src/USER-SMTBQ and src_pafi/USER-SMTBQ
Common subdirectories: src/USER-SPH and src_pafi/USER-SPH
Common subdirectories: src/USER-TALLY and src_pafi/USER-TALLY
Common subdirectories: src/USER-UEF and src_pafi/USER-UEF
Common subdirectories: src/USER-VTK and src_pafi/USER-VTK
Common subdirectories: src/VORONOI and src_pafi/VORONOI
